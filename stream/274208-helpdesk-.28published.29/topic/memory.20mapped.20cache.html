<html>
<head><meta charset="utf-8"><title>memory mapped cache · helpdesk (published) · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/index.html">helpdesk (published)</a></h2>
<h3>Topic: <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html">memory mapped cache</a></h3>

<hr>

<base href="https://julialang.zulipchat.com">

<head><link href="https://juliacommunity.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="293688980"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293688980" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293688980">(Aug 16 2022 at 10:23)</a>:</h4>
<p>For my code I often have a large amount of tensors stored in ram, but they typically aren't all required at the same time. Recalculating them whenever I need them would be extremely wasteful, so I was thinking that I could maybe create one big file, and memory map parts of that file as memory for the tensors. When I don't need them, the operating system can then write things out to disk and keep my memory usage relatively low.</p>
<p>The idea would be to create some kind of memory manager that simply tracks which parts of some backend file are currently being memory mapped, and I can request new memory mapped arrays from it. Bookkeeping to see what is freed up can then be done using finalizers.</p>
<p>My questions are:</p>
<ul>
<li>
<p>is this a good idea, or can I get better performance by manually read-writing things to disk as needed instead of relying on the OS to do this?</p>
</li>
<li>
<p>does something like this already exist?</p>
</li>
</ul>



<a name="293689245"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293689245" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293689245">(Aug 16 2022 at 10:25)</a>:</h4>
<p>memory mapping already does that</p>



<a name="293689453"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293689453" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293689453">(Aug 16 2022 at 10:27)</a>:</h4>
<p>The smallest amount of memory your OS manages for you is called a Page. When you memory map a file, the kernel more or less goes "I have a file of size X, so I need <code>ceil(X/SIZE_PAGE)</code> pages to store that. I won't fill them all, but when someone asks for memory in that region, I'll fill them lazily by loading from disk"</p>



<a name="293689833"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293689833" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293689833">(Aug 16 2022 at 10:30)</a>:</h4>
<p>right, but I would need some way of doing this for many different tensors so unless I use a new file per tensors (which potentially can be a ridiculous amount of many small files), I would still have to write some kind of "memory manager" which tracks which part of a file can be assigned again, right?</p>



<a name="293689911"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293689911" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293689911">(Aug 16 2022 at 10:30)</a>:</h4>
<p>memory mapping appears to do exactly what I want, and I want to do this for many small objects</p>



<a name="293690300"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690300" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690300">(Aug 16 2022 at 10:33)</a>:</h4>
<p>what do you mean with "assigned again"?</p>



<a name="293690314"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690314" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690314">(Aug 16 2022 at 10:33)</a>:</h4>
<p>memory mapping is a bidirectional operation</p>



<a name="293690388"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690388" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690388">(Aug 16 2022 at 10:34)</a>:</h4>
<p>the kernel already flushes old pages you haven't accessed in a while to disk</p>



<a name="293690461"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690461" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690461">(Aug 16 2022 at 10:34)</a>:</h4>
<p>memory mapping is a generic operation for the exact same thing - if you'd want your version to be efficient, you'd have to work on the page level as well, to keep things fast</p>



<a name="293690613"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690613" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690613">(Aug 16 2022 at 10:35)</a>:</h4>
<p>if the garbage collector frees up an array that was assigned to say bytes 10 - 20 for my file on disk, and my program wants to create a new tensor object that again requires 10 bytes, then I probably want to memory map again bytes 10-20 from the file, instead of growing it.</p>



<a name="293690686"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690686" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690686">(Aug 16 2022 at 10:36)</a>:</h4>
<p>that's a completely orthogonal thing</p>



<a name="293690784"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690784" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690784">(Aug 16 2022 at 10:37)</a>:</h4>
<p>if you want to work with memory mapping, you'll have to work with arrays (which are then memory mapped on disk)</p>



<a name="293690855"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293690855" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293690855">(Aug 16 2022 at 10:37)</a>:</h4>
<p>you wouldn't necessarily create new tensor objects, you'd mutate the array, either by assigning an existing index or mutating in place</p>



<a name="293691783"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293691783" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293691783">(Aug 16 2022 at 10:44)</a>:</h4>
<p>I'm probably not explaining myself very well.</p>
<p>let's say I have tensors (t1,t2,t3,t4), and I want to store them on disk and only load them in lazily. Now I can either create a seperate file for every object "t1.bin", "t2.bin", "t3.bin", ..., or I can create one big "db.bin", and memory map regions of that file to the respective arrays.</p>
<p>Now lets say I don't really need tensor t1 anymore, ever. The garbage collector cleans it up. I now do a new operation, which creates a new tensor, and this tensor is equally big as tensor "t1". I can now once again create a new file "t5.bin", or if I work with one big "db.bin", I can memory map a new region form "db.bin" for my new tensor.</p>
<p>This essentially means that "db.bin" would keep on growing and growing, despite large parts of that file not being needed anymore. I could probably do better, and keep track of what can be re-used, and whenever I require creating a new tensor, I could simply memory map a part of the file that was no long in use.</p>
<p>The alternative is to work with many small files, but a finalizer is not allowed to do IO, so I cannot automatically delete those files and clean things up.</p>



<a name="293692498"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293692498" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293692498">(Aug 16 2022 at 10:50)</a>:</h4>
<p>I understand what you're saying. What I'm saying is that memory mapping things that aren't page size is wasteful, as that's the smallest unit of memory the kernel can load/handle. So you need to have one big memory mapped file which you use as backing storage (nonideal, as you'd have to more or less write your own wrapper allocator around that and can't use existing interfaces to allocate it)</p>



<a name="293692603"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293692603" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293692603">(Aug 16 2022 at 10:51)</a>:</h4>
<p>what you're describing is more or less replacing/amending the existing GC, which is really not well supported in julia</p>



<a name="293693724"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293693724" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293693724">(Aug 16 2022 at 11:00)</a>:</h4>
<p>So what would you do, to provide some kind of lazy disk storage?</p>
<p>And also, what about it isn't well supported in julia? The implementation of mmap seems relatively simple, and I appear to be able to use pointer_to_array to use parts of my memory mapped region as arrays?</p>



<a name="293694632"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293694632" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293694632">(Aug 16 2022 at 11:07)</a>:</h4>
<p>I would first try to see if you can't save memory in other places first. The GC already reuses memory you can't reach anymore for new allocations - if you have lots of large, long lived allocations you don't actually need anymore (which is what would consume more memory) that to me suggests there are places in your code that can be made more efficient first.</p>



<a name="293694703"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293694703" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293694703">(Aug 16 2022 at 11:08)</a>:</h4>
<p>on the other hand, are you certain that recomputing the tensors is too expensive?</p>



<a name="293694800"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293694800" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293694800">(Aug 16 2022 at 11:08)</a>:</h4>
<p>what I was referring to with it not being well supported is that you can't e.g. just naively take the existing API, which may allocate regular GC memory instead of your special wrapped memory</p>



<a name="293694868"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293694868" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293694868">(Aug 16 2022 at 11:09)</a>:</h4>
<p>so you'll have to modify your tensors and the operations on them to be aware of the Mmapped memory, if you need to allocate intermediaries</p>



<a name="293695296"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293695296" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293695296">(Aug 16 2022 at 11:13)</a>:</h4>
<p>yes, though I could probably shave off a bit of my ram usage. It's a standard algorithm in physics called "DMRG", and to reach state of the art people are now really storing every individual tensor on disk, and load them in when necessary. It is much cheaper to read it out from disk then it is to recalculate the necessary tensors</p>



<a name="293695719"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293695719" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293695719">(Aug 16 2022 at 11:16)</a>:</h4>
<p>I would probably start out with writing a "send2disk" function, and copy regular GC allcoated memory over to a memory mapped region. It's an extra copy, but really simple to implement. I can go even further and directly allocate memory mapped arrays in a next step, but I'm not too sure if that'll be even necessary</p>



<a name="293695946"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293695946" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293695946">(Aug 16 2022 at 11:19)</a>:</h4>
<p>if your algorithm does all that explicitly anyway, I'd just <code>serialize</code> the tensors at points where you know you don't need them anymore</p>



<a name="293696117"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696117" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696117">(Aug 16 2022 at 11:20)</a>:</h4>
<p>I was hoping that I could offload that logic (serialize old tensors, keep recently used tensors still in ram) to the OS, precisely by using mmap</p>



<a name="293696270"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696270" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696270">(Aug 16 2022 at 11:22)</a>:</h4>
<p>you can't, not easily at least</p>



<a name="293696282"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696282" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696282">(Aug 16 2022 at 11:22)</a>:</h4>
<p>the OS has no concept of your tensors, it only knows blobs of memory</p>



<a name="293696317"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696317" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696317">(Aug 16 2022 at 11:22)</a>:</h4>
<p>GC knows about your objects, but it doesn't even try to use disk as potential backing storage for them</p>



<a name="293696334"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696334" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696334">(Aug 16 2022 at 11:23)</a>:</h4>
<p>you could try to increase your SWAP memory and just let GC do its thing</p>



<a name="293696424"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696424" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696424">(Aug 16 2022 at 11:23)</a>:</h4>
<p>either way, is your concern theoretical or are you running into actual OOM errors?</p>



<a name="293696549"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696549" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696549">(Aug 16 2022 at 11:25)</a>:</h4>
<p>At the moment I don't do any cache2disk things, and I run into OOM errors</p>



<a name="293696603"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696603" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696603">(Aug 16 2022 at 11:25)</a>:</h4>
<p>have you profiled/minimized allocations already?</p>



<a name="293696709"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696709" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696709">(Aug 16 2022 at 11:26)</a>:</h4>
<p>yes, the dominant memory usage are because of things that other people store on disk, and that I should also store on disk and only load in when necessary</p>



<a name="293696743"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696743" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696743">(Aug 16 2022 at 11:26)</a>:</h4>
<p>how are those other people solving that problem?</p>



<a name="293696798"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696798" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696798">(Aug 16 2022 at 11:27)</a>:</h4>
<p>are they using a custom allocator approach? This would be equivalent to subverting GC in julia.</p>



<a name="293696872"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696872" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696872">(Aug 16 2022 at 11:27)</a>:</h4>
<p>No, they manually store and load things from disk, and they hardcode this logic in the algorithm itself.</p>



<a name="293696977"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293696977" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293696977">(Aug 16 2022 at 11:28)</a>:</h4>
<p>then I'd follow that approach, as anything you could cook up in julia would look extremely similar, at least without replacing GC entirely</p>



<a name="293697084"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293697084" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293697084">(Aug 16 2022 at 11:29)</a>:</h4>
<p>But this is ugly and cumbersome to deal with, so a first step would be to create an array type that only keeps a few elements into ram, and serializes everything else to disk. That way, I don't have to deal with this bookkeeping in the core algorithm logic itself (where it imho doesn't belong)</p>



<a name="293697124"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293697124" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293697124">(Aug 16 2022 at 11:29)</a>:</h4>
<p>if you already have those points of serialization, you can definitely Mmap the individual backing arrays though</p>



<a name="293697191"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293697191" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293697191">(Aug 16 2022 at 11:30)</a>:</h4>
<p>yeah it doesn't belong there, but custom allocation schemes are not supported in julia</p>



<a name="293697221"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293697221" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293697221">(Aug 16 2022 at 11:30)</a>:</h4>
<p>they don't play nice with GC without extreme care</p>



<a name="293740887"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293740887" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293740887">(Aug 16 2022 at 15:31)</a>:</h4>
<p>But for example something like this : </p>
<p><a href="https://gist.github.com/maartenvd/a265cbcbb3eb5cb3e9915861ff158569">https://gist.github.com/maartenvd/a265cbcbb3eb5cb3e9915861ff158569</a></p>
<p>wouldn't something like this work just fine?</p>



<a name="293741220"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293741220" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293741220">(Aug 16 2022 at 15:32)</a>:</h4>
<p>it's not very pretty, and there are probably much nicer strategies then using findfirst</p>



<a name="293741503"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293741503" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293741503">(Aug 16 2022 at 15:34)</a>:</h4>
<p>to speed things up, I can be more intellegent about alligning larger tensors to the start of a page</p>



<a name="293748946"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293748946" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293748946">(Aug 16 2022 at 16:10)</a>:</h4>
<p>yes it would work, but you'd have to take care not to accidentally get an array that isn't managed by your allocator</p>



<a name="293749002"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293749002" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293749002">(Aug 16 2022 at 16:11)</a>:</h4>
<p>for that to work in general, your tensor library would probably need to be aware of that</p>



<a name="293749075"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293749075" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293749075">(Aug 16 2022 at 16:11)</a>:</h4>
<p>I'm not sure how growing a tensor vector would work or if that's required, but it would probably break under that scheme</p>



<a name="293749181"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293749181" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293749181">(Aug 16 2022 at 16:12)</a>:</h4>
<p>you can probably also run into some other race conditions, if the finalizers run late</p>



<a name="293749224"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293749224" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293749224">(Aug 16 2022 at 16:12)</a>:</h4>
<p>they're not guaranteed to run eagerly, after all</p>



<a name="293750543"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293750543" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293750543">(Aug 16 2022 at 16:19)</a>:</h4>
<p>yes, the tensor library never "grows" the data; which in any case wouldn't be a problem as it will simply result in a tensor that lives entirely in ram - which is the current status anyway.</p>
<p>I thought briefly about race conditions, but I don't think there's a real problem. The only way the memory manager finalizer can be called is if the arrays that were created through it are also all going to be garbage collected (as their finalizers hold a reference to the memory manager), so that doesn't appear to be a problem (though I don't really know a lot about that).</p>



<a name="293751238"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293751238" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293751238">(Aug 16 2022 at 16:23)</a>:</h4>
<p>although now I think about it, push!/append! would indeed kinda be a problem, as some memory in the memory mapped file will not be freed, despite it not being used either.</p>



<a name="293753629"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293753629" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293753629">(Aug 16 2022 at 16:28)</a>:</h4>
<p>ah but push!/append! doesn't work. The array from unsafe_wrap is "shared", so I will get errors in that case :)</p>



<a name="293753795"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/293753795" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#293753795">(Aug 16 2022 at 16:29)</a>:</h4>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">mn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DiskManager</span><span class="p">(</span><span class="s">"derp3.bin"</span><span class="p">,</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate!</span><span class="p">(</span><span class="n">mn2</span><span class="p">,</span><span class="kt">Array</span><span class="p">{</span><span class="kt">ComplexF64</span><span class="p">,</span><span class="mi">1</span><span class="p">},(</span><span class="mi">10</span><span class="p">,));</span><span class="w"></span>
<span class="n">append!</span><span class="p">(</span><span class="n">arr</span><span class="p">,[</span><span class="mf">1.0</span><span class="p">])</span><span class="w"></span>
</code></pre></div>
<p>errors</p>



<a name="294042350"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294042350" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294042350">(Aug 18 2022 at 09:44)</a>:</h4>
<p>In trying to further implement this diskamanger thing,I ran into the sublety of finalizers and thread safety. My diskmanager has a lock, but the finalizer of the arrays I allocated also need to acquire this lock in order to signal that this data can be freed. This in turn could lead to a recursive lock deadlock.</p>
<p>The documentation recommends</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">A</span><span class="w"> </span><span class="n">related</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="n">strategy</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">yield</span><span class="o">-</span><span class="n">free</span><span class="w"> </span><span class="n">queue</span><span class="o">.</span><span class="w"> </span><span class="n">We</span><span class="w"> </span><span class="n">don</span><span class="o">'</span><span class="n">t</span><span class="w"> </span><span class="n">currently</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">free</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Base</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">Base</span><span class="o">.</span><span class="kt">InvasiveLinkedListSynchronized</span><span class="p">{</span><span class="kt">T</span><span class="p">}</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">suitable</span><span class="o">.</span><span class="w"></span>
</code></pre></div>
<p>In what way is this type "suitable"? Is it simply a thread safe list, or is it special, in the sense that during execution it never yields to finalizers?</p>



<a name="294043876"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294043876" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294043876">(Aug 18 2022 at 09:54)</a>:</h4>
<p>both</p>



<a name="294044043"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044043" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044043">(Aug 18 2022 at 09:55)</a>:</h4>
<p>"yielding to a finalizer" doesn't really make sense, as finalizers are not tasks. they can't be yielded to. What the comment is referring to is that you really don't want to be interrupted by GC when you do such work (as you have no idea when you will be scheduled again), so you need a lock-free, non-yielding queue</p>



<a name="294044096"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044096" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044096">(Aug 18 2022 at 09:55)</a>:</h4>
<p>GC is allowed to run at yieldpoints, so yielding is a nogo</p>



<a name="294044203"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044203" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044203">(Aug 18 2022 at 09:56)</a>:</h4>
<p>and invasivelinkedlistsynchronizd is written in such a way that during operations on this type, it won't be interrupted by the GC?</p>



<a name="294044351"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044351" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044351">(Aug 18 2022 at 09:58)</a>:</h4>
<p>according to that comment, yes, but I don't recall where that comment is from, so I can't say much more</p>



<a name="294044436"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044436" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044436">(Aug 18 2022 at 09:58)</a>:</h4>
<p><a href="https://engaging-web.mit.edu/~alir/cnhlab004/julia-1.5.3/share/doc/julia/html/en/manual/multi-threading.html">https://engaging-web.mit.edu/~alir/cnhlab004/julia-1.5.3/share/doc/julia/html/en/manual/multi-threading.html</a></p>
<p>safe use of finalizers, the julia docs</p>



<a name="294044576"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044576" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044576">(Aug 18 2022 at 09:59)</a>:</h4>
<p>aah, your context was running this as part of a finalizer, yes?</p>



<a name="294044585"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044585" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044585">(Aug 18 2022 at 09:59)</a>:</h4>
<p>yes</p>



<a name="294044657"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044657" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044657">(Aug 18 2022 at 10:00)</a>:</h4>
<p>Yes, the problem is that finalizers are not allowed to yield to other tasks, as that can potentially leave an object half-cleaned up</p>



<a name="294044769"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044769" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044769">(Aug 18 2022 at 10:00)</a>:</h4>
<p>btw, which version of julia are you running? those docs you linked are neither official nor the most recent version</p>



<a name="294044859"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294044859" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294044859">(Aug 18 2022 at 10:01)</a>:</h4>
<p>ah I'm on 1.8 rc4, and google simply happened to drop me there instead of the official docs</p>



<a name="294045016"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294045016" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294045016">(Aug 18 2022 at 10:02)</a>:</h4>
<p>it's still there for 1.8 <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#Safe-use-of-Finalizers">https://docs.julialang.org/en/v1/manual/multi-threading/#Safe-use-of-Finalizers</a></p>



<a name="294045053"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294045053" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294045053">(Aug 18 2022 at 10:02)</a>:</h4>
<p>grr, google</p>



<a name="294045105"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294045105" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294045105">(Aug 18 2022 at 10:03)</a>:</h4>
<p>yeah, the point is that old versions may have a different wording</p>



<a name="294045145"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294045145" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294045145">(Aug 18 2022 at 10:03)</a>:</h4>
<p>or the newer version made some relevant clarification</p>



<a name="294045713"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294045713" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294045713">(Aug 18 2022 at 10:06)</a>:</h4>
<p>let me quickly sketch the situation:</p>
<p>I have a DiskManager, which essentially has a large byte array and a list of memory regions in use.</p>
<p>If I allocate an array, I want to attach a finalizer to this array that tells the underlying diskmanager that this memory is no longer in use.</p>
<p>I want this thread safe, so DiskManager needs to acquire a lock during allocation, and the finalizers of the array also need to acquire the same lock when "freeing up" the data. Using lock() in the finalizer would result in deadlocks.</p>
<p>The documentation recommends another approach as well - the delayed finalizers - but this appears to segfault if I use an anonymous function as finalizer:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="n">A_finalizer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">trylock</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">hit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findfirst</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">dm</span><span class="o">.</span><span class="n">offsets</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">deleteat!</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span><span class="n">hit</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">unlock</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="c"># couldn't get the lock; delay finalizer</span><span class="w"></span>
<span class="w">            </span><span class="n">finalizer</span><span class="p">(</span><span class="n">A_finalizer</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="nb">nothing</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
</code></pre></div>



<a name="294046225"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294046225" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294046225">(Aug 18 2022 at 10:09)</a>:</h4>
<p>but if InvasieLinkedList operations are indeed never interrupted by the garbage collector, then I can simply use that</p>



<a name="294046642"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294046642" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294046642">(Aug 18 2022 at 10:12)</a>:</h4>
<p>going through the code of this List type, I don't quite see what makes it special; that it won't be interrupted by the GC</p>



<a name="294046966"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294046966" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294046966">(Aug 18 2022 at 10:14)</a>:</h4>
<p>I think they're just referring to it being safe to be interrupted at any time, as the critical region is atomic?</p>



<a name="294046979"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294046979" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294046979">(Aug 18 2022 at 10:14)</a>:</h4>
<p>not too familiar with its internals though</p>



<a name="294047020"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047020" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047020">(Aug 18 2022 at 10:15)</a>:</h4>
<p>remember, you can be interrupted by other finalizers too</p>



<a name="294047086"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047086" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047086">(Aug 18 2022 at 10:15)</a>:</h4>
<p>I don't know how that type would be used - presumably you'd have to attach it to custom structs as an inline field, as its an <code>InvasiveLinkedList</code></p>



<a name="294047474"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047474" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047474">(Aug 18 2022 at 10:18)</a>:</h4>
<p>when an array is finalized, I would simply push that information to an InvasiveLinkedListSynchronized in the DiskManager. Then, during allocate!, I can acquire the DiskManager lock, and process all this "region X is freed up" information in the InvasiveLinkedListSynchronized</p>



<a name="294047525"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047525" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047525">(Aug 18 2022 at 10:18)</a>:</h4>
<p>that's not how invasive linked lists work though</p>



<a name="294047573"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047573" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047573">(Aug 18 2022 at 10:19)</a>:</h4>
<p>the whole point of them is to not interact with GC, i.e. not having to allocate new memory</p>



<a name="294047596"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047596" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047596">(Aug 18 2022 at 10:19)</a>:</h4>
<p>"pushing" to an array potentially needs to switch to the GC, since it may have to move an array around</p>



<a name="294047745"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047745" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047745">(Aug 18 2022 at 10:20)</a>:</h4>
<p>invasive linked lists work by already being part of the object that's going to be part of the list - all "pushing" an element to that list does is let its parent know where its child is (and vice versa, if it's a doubly linked list)</p>



<a name="294047863"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294047863" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294047863">(Aug 18 2022 at 10:21)</a>:</h4>
<p>that's why they're safe to use for such applications, all the memory that's required for managing them was already allocated as part of the object itself</p>



<a name="294048358"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294048358" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294048358">(Aug 18 2022 at 10:24)</a>:</h4>
<p>ah ok, I had no clue what invasive linked lists actually were</p>



<a name="294049081"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294049081" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294049081">(Aug 18 2022 at 10:29)</a>:</h4>
<p>I could simply disable finalizers temporarily a la <a href="https://github.com/JuliaGPU/CuArrays.jl/commit/2258a24a6c1927a9acac6ca19ea604dc633e2028">https://github.com/JuliaGPU/CuArrays.jl/commit/2258a24a6c1927a9acac6ca19ea604dc633e2028</a></p>



<a name="294049320"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294049320" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294049320">(Aug 18 2022 at 10:31)</a>:</h4>
<p>I would also have to disable finalizers while runing the finalizer itself, to prevent different finalizers interrupting eachother. Is that even allowed?</p>



<a name="294049551"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294049551" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294049551">(Aug 18 2022 at 10:34)</a>:</h4>
<p>I don't know, but it doesn't sound good</p>



<a name="294049791"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294049791" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294049791">(Aug 18 2022 at 10:35)</a>:</h4>
<p>I'd check whether they're using that macro in finalizers themselves</p>



<a name="294049878"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294049878" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294049878">(Aug 18 2022 at 10:36)</a>:</h4>
<p>all they're doing is making sure that their critical portion is not interrupted by finalizers</p>



<a name="294052280"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294052280" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294052280">(Aug 18 2022 at 10:53)</a>:</h4>
<p>aha = <a href="https://github.com/JuliaLang/julia/pull/38487">https://github.com/JuliaLang/julia/pull/38487</a></p>



<a name="294052369"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294052369" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294052369">(Aug 18 2022 at 10:54)</a>:</h4>
<p>no finalizers are run if any lock is acquired!</p>



<a name="294052526"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294052526" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294052526">(Aug 18 2022 at 10:55)</a>:</h4>
<p>correction - this is only true if I use Reentrantlock</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">Calling</span><span class="w"> </span><span class="err">'</span><span class="n">lock</span><span class="o">'</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">inhibit</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">finalizers</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">corresponding</span><span class="w"></span>
<span class="w">  </span><span class="err">'</span><span class="n">unlock</span><span class="o">'.</span><span class="w"></span>
</code></pre></div>



<a name="294131652"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/memory%20mapped%20cache/near/294131652" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/memory.20mapped.20cache.html#294131652">(Aug 18 2022 at 17:17)</a>:</h4>
<p>so it finally works with surprisingly reasonable performance, given how stupid my allocator implementation is. One annoying caveat is that I rely on the julia GC to free up memory; but the GC has no idea how much memory I still have available in my file, and whether I'm close to running out. A very similar issue to what the CUDA people appear to have</p>



<hr><p>Last updated: Nov 01 2025 at 04:39 UTC</p>
</html>