<html>
<head><meta charset="utf-8"><title>Constraining method signatures · helpdesk (published) · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/index.html">helpdesk (published)</a></h2>
<h3>Topic: <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html">Constraining method signatures</a></h3>

<hr>

<base href="https://julialang.zulipchat.com">

<head><link href="https://juliacommunity.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="262302620"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262302620" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jesper Stemann Andersen <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262302620">(Nov 22 2021 at 10:39)</a>:</h4>
<p>How to be more type-specific than <code>::Function</code> when passing methods to methods (defining higher-order functions) or defining structs with methods as fields?</p>
<p>Just use <a href="https://github.com/yuyichao/FunctionWrappers.jl">https://github.com/yuyichao/FunctionWrappers.jl</a> ?</p>



<a name="262302844"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262302844" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Pfitzner <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262302844">(Nov 22 2021 at 10:41)</a>:</h4>
<p>why do you want to do that?</p>



<a name="262303206"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262303206" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Maarten <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262303206">(Nov 22 2021 at 10:45)</a>:</h4>
<p>for structs with methods as fields I just use </p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">struct</span> <span class="kt">test</span><span class="p">{</span><span class="kt">A</span><span class="p">}</span>
<span class="n">fun</span><span class="o">::</span><span class="kt">A</span>
<span class="k">end</span>
</code></pre></div>
<p>julia is then able to infer the exact fun, and keeps things type stable</p>



<a name="262303463"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262303463" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Pfitzner <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262303463">(Nov 22 2021 at 10:48)</a>:</h4>
<p>yeah, I was mostly asking about the first usecase</p>



<a name="262304070"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262304070" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jesper Stemann Andersen <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262304070">(Nov 22 2021 at 10:55)</a>:</h4>
<p>In a related thread, <span class="user-mention silent" data-user-id="269150">Mason Protter</span>: <a href="#narrow/stream/225542-helpdesk/topic/Methods.20of.20a.20function/near/203571606">answers</a> that basically, this is not what you would do in Julia - you would prefer not to constrain the Function, as that would hinder the inter-operability of methods - i.e. "dispatch nirvana".</p>
<p>But how do I explain to colleagues that their "Pythonic" or "Csharpish" way of doing things is not "Julian"? :-) A really strong point (in my memory) of the micro-benchmarks once highlighted was  "you can write any sort of algorithm in Julia". And indeed you can. But can I get type inference (and hence static type analysis) as well, please? :-)</p>
<p>So use case: Inferrable types - code navigation etc.</p>



<a name="262307439"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262307439" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262307439">(Nov 22 2021 at 11:34)</a>:</h4>
<p>you use <code>where F</code></p>



<a name="262307497"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262307497" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262307497">(Nov 22 2021 at 11:34)</a>:</h4>
<p>see also <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing</a></p>



<a name="262307567"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262307567" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262307567">(Nov 22 2021 at 11:35)</a>:</h4>
<p>in general <code>::T</code> in a function signature _does not generally improve performance or inferrability_ - it is mainly a tool for deciding dispatch</p>



<a name="262307586"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262307586" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262307586">(Nov 22 2021 at 11:36)</a>:</h4>
<p>this may be unfamiliar to people used to static languages like java or C# - julia is a dynamic (though compiled) language</p>



<a name="262307648"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262307648" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262307648">(Nov 22 2021 at 11:36)</a>:</h4>
<p>these things are not exclusive!</p>



<a name="262311045"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262311045" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jesper Stemann Andersen <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262311045">(Nov 22 2021 at 12:18)</a>:</h4>
<p>Ah, I see, so in the following, <code>f2</code> enable more specialization than <code>f1</code>? </p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">f1</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">Function</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">f2</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">F</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">where</span> <span class="kt">F</span> <span class="o">&lt;:</span> <span class="kt">Function</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>
<p>I can't quite see the difference:</p>
<div class="codehilite" data-code-language="Julia console"><pre><span></span><code><span class="gp">julia&gt;</span> <span class="p">(</span><span class="nd">@which</span> <span class="n">f1</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">specializations</span>
<span class="go">svec(MethodInstance for f1(::typeof(sin), ::Float64), MethodInstance for f1(::typeof(sin), ::Int64), #undef, #undef, #undef, #undef, #undef, #undef)</span>

<span class="gp">julia&gt;</span> <span class="p">(</span><span class="nd">@which</span> <span class="n">f2</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">specializations</span>
<span class="go">svec(MethodInstance for f2(::typeof(sin), ::Float64), MethodInstance for f2(::typeof(sin), ::Int64), #undef, #undef, #undef, #undef, #undef, #undef)</span>
</code></pre></div>



<a name="262312064"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262312064" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jesper Stemann Andersen <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262312064">(Nov 22 2021 at 12:30)</a>:</h4>
<p>I am actually not looking for performance - what I am seeking is inferability - to enable static analysis (whether by a human or JET). I would prefer to constrain the methods that will be accepted, such that my program is more expressive - more clear.</p>
<p>Despite that "Julian"/dispatch-way of doing it, where "it" being a function <code>f</code> of two objects dependent on a distance measure, might be:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">abstract type</span> <span class="kt">AbstractFoo</span> <span class="k">end</span>

<span class="k">abstract type</span> <span class="kt">AbstractFooDistance</span> <span class="k">end</span>

<span class="k">struct</span> <span class="kt">FooDistance1</span> <span class="k">end</span>
<span class="k">struct</span> <span class="kt">FooDistance2</span> <span class="k">end</span>

<span class="n">dist</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">d</span><span class="o">::</span><span class="kt">FooDistance1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">dist</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">d</span><span class="o">::</span><span class="kt">FooDistance2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">f</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">d</span><span class="o">::</span><span class="kt">AbstractFooDistance</span><span class="p">)</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</code></pre></div>
<p>The  most common approach would be:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">abstract type</span> <span class="kt">AbstractFoo</span> <span class="k">end</span>

<span class="n">dist1</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">dist2</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">f</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">d</span><span class="o">::</span><span class="kt">Function</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">)</span>
</code></pre></div>
<p>which leaves <code>d</code> quite open.</p>
<p>A <code>FunctionWrapper</code> seems to enable specifying the signature of accepted <code>d</code>'s:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">f</span><span class="p">(</span><span class="n">foo1</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">foo2</span><span class="o">::</span><span class="kt">AbstractFoo</span><span class="p">,</span> <span class="n">d</span><span class="o">::</span><span class="kt">FunctionWrapper</span><span class="p">{</span><span class="kt">Int</span><span class="p">,(</span><span class="kt">AbstractFoo</span><span class="p">,</span><span class="kt">AbstractFoo</span><span class="p">)})</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">)</span>
</code></pre></div>
<p>... at the cost of having to wrap the functions at the call sites:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">f</span><span class="p">(</span><span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">,</span> <span class="kt">FunctionWrapper</span><span class="p">{</span><span class="kt">Int</span><span class="p">,(</span><span class="kt">AbstractFoo</span><span class="p">,</span><span class="kt">AbstractFoo</span><span class="p">)}(</span><span class="n">dist1</span><span class="p">))</span>
</code></pre></div>



<a name="262314015"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314015" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314015">(Nov 22 2021 at 12:50)</a>:</h4>
<blockquote>
<p>I can't quite see the difference:</p>
</blockquote>
<p>See:</p>
<blockquote>
<p>Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function.</p>
</blockquote>



<a name="262314053"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314053" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314053">(Nov 22 2021 at 12:50)</a>:</h4>
<p>it will still infer correctly, it just may not need to specialize</p>



<a name="262314093"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314093" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314093">(Nov 22 2021 at 12:51)</a>:</h4>
<p>i.e. the differently inferred methods may point to the same non-specialized code</p>



<a name="262314218"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314218" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314218">(Nov 22 2021 at 12:52)</a>:</h4>
<p>unless you really need <code>FunctionWrappers</code>, I wouldn't start with it in mind</p>



<a name="262314293"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314293" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314293">(Nov 22 2021 at 12:52)</a>:</h4>
<p>in general, julia style seems to be shallower type hierarchies, in contrast to e.g. Java or C#, where very deeply nested type hierarchies are common</p>



<a name="262314366"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262314366" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262314366">(Nov 22 2021 at 12:53)</a>:</h4>
<p>one reason for this is that abstract types don't hold state, i.e. there is no structural inheritance</p>



<a name="262319105"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262319105" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jesper Stemann Andersen <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262319105">(Nov 22 2021 at 13:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306754">Sukera</span> <a href="#narrow/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures/near/262314218">said</a>:</p>
<blockquote>
<p>unless you really need <code>FunctionWrappers</code>, I wouldn't start with it in mind</p>
</blockquote>
<p>We don't - I prefer to define the distance types and let dispatch handle it - i.e., avoiding <code>::Function</code>. It was more for sake of argument - saying "you shouldn't do it like that - that's not the way it should be done in Julia" doesn't feel like a strong argument.</p>



<a name="262322412"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262322412" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262322412">(Nov 22 2021 at 14:05)</a>:</h4>
<p>This sounds related to a problem I've run into a few times. If you pass <code>f</code> as a function (generically or <code>::Function</code>) you usually can't know anything statically about the function.</p>
<p>It's often useful to know "this function returns a function" or "this function returns a lower-triangular matrix of Float64s". Ideally, there could even be a way to dispatch on things like this. But Julia isn't set up this way. For dispatch, you can only do <code>::Function</code> or <code>::typeof(f)</code>. You either know nothing or everything, there's no in between. So you're often stuck with just running it and seeing what you get. In cases where the function is expensive, this can be painful.</p>
<p>I had high hopes for <code>Core.Compiler.return_type</code>, but currently it doesn't seem to help much. Maybe that will change?</p>



<a name="262323502"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262323502" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262323502">(Nov 22 2021 at 14:13)</a>:</h4>
<p><code>Core.Compiler.return_type</code> itself is internal anyway, no?</p>



<a name="262323528"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262323528" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262323528">(Nov 22 2021 at 14:13)</a>:</h4>
<p>if we get to dispatch on something like that, we will probably get syntax for it</p>



<a name="262323585"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262323585" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262323585">(Nov 22 2021 at 14:14)</a>:</h4>
<p>at its core, julia is still a dynamic language, you have to keep that in mind - just because we _can_ access some things from the compiler, doesn't mean we necessarily should</p>



<a name="262323646"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262323646" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262323646">(Nov 22 2021 at 14:14)</a>:</h4>
<p>(though I do think this desire will only grow stronger, to support static binaries better)</p>



<a name="262326411"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262326411" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262326411">(Nov 22 2021 at 14:34)</a>:</h4>
<p>I'd argue the opposite of that - It's referred to as a dynamic language, but just because you <em>can</em> ignore the types doesn't mean you should <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> </p>
<p>I like Keno's description of "locally static neighborhoods" as the key to Julia's performance. So to make things better and faster, we should make those neighborhoods bigger, when we can. </p>
<p>As for functions, the best workaround I've found for this is making structs callable, then using a type hierarchy for dispatch. Then you can dispatch on abstract types to encode things you know statically.</p>



<a name="262340431"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262340431" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simeon Schaub <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262340431">(Nov 22 2021 at 16:12)</a>:</h4>
<blockquote>
<p>I had high hopes for <code>Core.Compiler.return_type</code>, but currently it doesn't seem to help much. Maybe that will change?</p>
</blockquote>
<p>What do you mean by that? <code>return_type</code> does exactly what it's supposed to. Dispatching on it OTOH is usually a bad idea though, since because of the way Julia is designed, type inference is never guaranteed to be exact, so <code>Any</code> is always a valid answer for <code>return_type</code>.</p>



<a name="262341545"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262341545" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262341545">(Nov 22 2021 at 16:19)</a>:</h4>
<p>Just that it seems to return <code>Any</code> for cases that seem reasonable to infer. Maybe there's a way to help it, say adding methods to cases I know? Would that propagate correctly?</p>



<a name="262342333"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262342333" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262342333">(Nov 22 2021 at 16:24)</a>:</h4>
<p>depends on the specific case</p>



<a name="262358928"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262358928" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262358928">(Nov 22 2021 at 18:28)</a>:</h4>
<p>no idea if this is useful to you but you can always do this sort of pattern:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">struct</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span> <span class="o">&lt;:</span> <span class="kt">Tuple</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span>
    <span class="n">f</span><span class="o">::</span><span class="kt">F</span>
<span class="k">end</span>

<span class="n">MethodWrapper</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">F</span><span class="p">,</span> <span class="n">Ts</span><span class="p">)</span>  <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">}</span>           <span class="o">=</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">toTuple</span><span class="p">(</span><span class="kt">Ts</span><span class="p">),</span> <span class="kt">Any</span><span class="p">}(</span><span class="n">f</span><span class="p">)</span>
<span class="n">MethodWrapper</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">F</span><span class="p">,</span> <span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">::</span><span class="kt">Pair</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">}</span> <span class="o">=</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">toTuple</span><span class="p">(</span><span class="kt">Ts</span><span class="p">),</span>   <span class="kt">R</span><span class="p">}(</span><span class="n">f</span><span class="p">)</span>
<span class="n">toTuple</span><span class="p">(</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">T</span><span class="p">})</span> <span class="k">where</span> <span class="p">{</span><span class="kt">T</span><span class="p">}</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">T</span><span class="p">}</span>
<span class="n">toTuple</span><span class="p">(</span><span class="n">Ts</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Ts</span><span class="o">...</span><span class="p">}</span>

<span class="p">(</span><span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">R</span><span class="p">})(</span>  <span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span><span class="o">::</span><span class="kt">R</span>
<span class="p">(</span><span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">Any</span><span class="p">})(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">}</span>    <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>

<span class="k">function</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="kt">IO</span><span class="p">,</span> <span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span><span class="p">,</span> <span class="kt">R</span><span class="p">})</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span> <span class="o">&lt;:</span> <span class="kt">Tuple</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="s">"(::</span><span class="si">$</span><span class="p">(</span><span class="n">Ts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="s">", ::</span><span class="si">$</span><span class="p">(</span><span class="n">Ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="s">"</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">Ts</span><span class="p">))</span><span class="o">...</span><span class="p">,</span> <span class="s">")::</span><span class="si">$R</span><span class="s">"</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">macro</span> <span class="n">method</span><span class="p">(</span><span class="n">ex</span><span class="o">::</span><span class="kt">Expr</span><span class="p">)</span>
    <span class="nd">@assert</span> <span class="n">ex</span><span class="o">.</span><span class="n">head</span> <span class="o">∈</span> <span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="ss">:call</span>
        <span class="n">R</span> <span class="o">=</span> <span class="kt">Any</span>
    <span class="k">else</span>
        <span class="n">R</span>  <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="p">])</span> <span class="k">do</span> <span class="n">arg</span><span class="o">::</span><span class="kt">Expr</span>
        <span class="nd">@assert</span> <span class="n">arg</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">)</span>
        <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">length</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">)]</span>
    <span class="k">end</span>
    <span class="n">esc</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="n">MethodWrapper</span><span class="p">(</span><span class="o">$</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="kt">Tuple</span><span class="p">(</span><span class="n">Ts</span><span class="p">)</span><span class="o">...</span><span class="p">),)</span> <span class="o">=&gt;</span> <span class="o">$</span><span class="n">R</span><span class="p">)))</span>
<span class="k">end</span>
</code></pre></div>



<a name="262358996"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262358996" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262358996">(Nov 22 2021 at 18:29)</a>:</h4>
<p>and then</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="n">m</span> <span class="o">=</span> <span class="nd">@method</span> <span class="n">f</span><span class="p">(</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span> <span class="o">::</span><span class="kt">Complex</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Complex</span>

<span class="c">#+RESULTS:</span>
 <span class="n">f</span><span class="p">(</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span> <span class="o">::</span><span class="kt">Complex</span><span class="p">)</span><span class="o">::</span><span class="kt">Complex</span>
</code></pre></div>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c">#+RESULTS:</span>
 <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">typeof</span><span class="p">(</span><span class="kt">f</span><span class="p">),</span><span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span><span class="kt">Complex</span><span class="p">},</span><span class="kt">Complex</span><span class="p">}</span>
</code></pre></div>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">im</span><span class="p">)</span>

<span class="c">#+RESULTS:</span>
 <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span>
</code></pre></div>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">m2</span> <span class="o">=</span> <span class="nd">@method</span> <span class="n">f</span><span class="p">(</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span> <span class="o">::</span><span class="kt">Complex</span><span class="p">)</span><span class="o">::</span><span class="kt">Real</span>
<span class="n">m2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span> <span class="nb">im</span><span class="p">)</span>

<span class="c">#+RESULTS:</span>
 <span class="kt">TypeError</span><span class="o">:</span> <span class="k">in</span> <span class="n">typeassert</span><span class="p">,</span> <span class="n">expected</span> <span class="kt">Real</span><span class="p">,</span> <span class="n">got</span> <span class="n">a</span> <span class="n">value</span> <span class="n">of</span> <span class="n">type</span> <span class="kt">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span>
</code></pre></div>



<a name="262360302"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262360302" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262360302">(Nov 22 2021 at 18:40)</a>:</h4>
<p>Ok this is really interesting:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@benchmark</span> <span class="o">$</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">rand</span><span class="p">();</span> <span class="n">b</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span><span class="nb">im</span><span class="p">)</span>
<span class="n">BenchmarkTools</span><span class="o">.</span><span class="n">Trial</span><span class="o">:</span> <span class="mi">10000</span> <span class="n">samples</span> <span class="n">with</span> <span class="mi">1000</span> <span class="n">evaluations</span><span class="o">.</span>
 <span class="n">Range</span> <span class="p">(</span><span class="n">min</span> <span class="o">…</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span>  <span class="mf">1.162</span> <span class="n">ns</span> <span class="o">…</span> <span class="mf">4.749</span> <span class="n">ns</span>  <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">min</span> <span class="o">…</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.00</span><span class="o">%</span> <span class="o">…</span> <span class="mf">0.00</span><span class="o">%</span>
 <span class="n">Time</span>  <span class="p">(</span><span class="n">median</span><span class="p">)</span><span class="o">:</span>     <span class="mf">1.172</span> <span class="n">ns</span>             <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">median</span><span class="p">)</span><span class="o">:</span>    <span class="mf">0.00</span><span class="o">%</span>
 <span class="n">Time</span>  <span class="p">(</span><span class="n">mean</span> <span class="o">±</span> <span class="n">σ</span><span class="p">)</span><span class="o">:</span>   <span class="mf">1.179</span> <span class="n">ns</span> <span class="o">±</span> <span class="mf">0.074</span> <span class="n">ns</span>  <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">mean</span> <span class="o">±</span> <span class="n">σ</span><span class="p">)</span><span class="o">:</span>  <span class="mf">0.00</span><span class="o">%</span> <span class="o">±</span> <span class="mf">0.00</span><span class="o">%</span>

               <span class="n">█</span>
  <span class="n">▂▁▁▁▁▁▁▁▁▁▁▁▁█▁▆▁▁▁▁▁▁▁▁▁▁▁▅▁▃▁▁▁▁▁▁▁▁▁▁▁▃▁▂▁▁▁▁▁▁▁▁▁▁▁▃▂</span> <span class="n">▂</span>
  <span class="mf">1.16</span> <span class="n">ns</span>        <span class="n">Histogram</span><span class="o">:</span> <span class="n">frequency</span> <span class="n">by</span> <span class="n">time</span>        <span class="mf">1.2</span> <span class="n">ns</span> <span class="o">&lt;</span>

 <span class="n">Memory</span> <span class="n">estimate</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">allocs</span> <span class="n">estimate</span><span class="o">:</span> <span class="mf">0.</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@benchmark</span> <span class="o">$</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">rand</span><span class="p">();</span> <span class="n">b</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span><span class="nb">im</span><span class="p">)</span>
<span class="n">BenchmarkTools</span><span class="o">.</span><span class="n">Trial</span><span class="o">:</span> <span class="mi">10000</span> <span class="n">samples</span> <span class="n">with</span> <span class="mi">1000</span> <span class="n">evaluations</span><span class="o">.</span>
 <span class="n">Range</span> <span class="p">(</span><span class="n">min</span> <span class="o">…</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span>  <span class="mf">1.162</span> <span class="n">ns</span> <span class="o">…</span> <span class="mf">4.819</span> <span class="n">ns</span>  <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">min</span> <span class="o">…</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.00</span><span class="o">%</span> <span class="o">…</span> <span class="mf">0.00</span><span class="o">%</span>
 <span class="n">Time</span>  <span class="p">(</span><span class="n">median</span><span class="p">)</span><span class="o">:</span>     <span class="mf">1.182</span> <span class="n">ns</span>             <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">median</span><span class="p">)</span><span class="o">:</span>    <span class="mf">0.00</span><span class="o">%</span>
 <span class="n">Time</span>  <span class="p">(</span><span class="n">mean</span> <span class="o">±</span> <span class="n">σ</span><span class="p">)</span><span class="o">:</span>   <span class="mf">1.182</span> <span class="n">ns</span> <span class="o">±</span> <span class="mf">0.067</span> <span class="n">ns</span>  <span class="n">┊</span> <span class="n">GC</span> <span class="p">(</span><span class="n">mean</span> <span class="o">±</span> <span class="n">σ</span><span class="p">)</span><span class="o">:</span>  <span class="mf">0.00</span><span class="o">%</span> <span class="o">±</span> <span class="mf">0.00</span><span class="o">%</span>

                <span class="n">█</span>             <span class="n">▆</span>             <span class="n">▆</span>
  <span class="n">█▃▁▁▁▁▁▁▁▁▁▁▁▁█▅▁▁▁▁▁▁▁▁▁▁▁▁█▅▁▁▁▁▁▁▁▁▁▁▁▁█▁▆▁▁▁▁▁▁▁▁▁▁▁▂</span> <span class="n">▃</span>
  <span class="mf">1.16</span> <span class="n">ns</span>        <span class="n">Histogram</span><span class="o">:</span> <span class="n">frequency</span> <span class="n">by</span> <span class="n">time</span>        <span class="mf">1.2</span> <span class="n">ns</span> <span class="o">&lt;</span>

 <span class="n">Memory</span> <span class="n">estimate</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">allocs</span> <span class="n">estimate</span><span class="o">:</span> <span class="mf">0.</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Core</span><span class="o">.</span><span class="n">Compiler</span><span class="o">.</span><span class="n">return_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Complex</span><span class="p">})</span>
<span class="kt">Complex</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Core</span><span class="o">.</span><span class="n">Compiler</span><span class="o">.</span><span class="n">return_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Complex</span><span class="p">})</span>
<span class="kt">Any</span>
</code></pre></div>



<a name="262361082"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262361082" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262361082">(Nov 22 2021 at 18:47)</a>:</h4>
<p>it's not too surprising imo</p>



<a name="262361100"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262361100" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262361100">(Nov 22 2021 at 18:47)</a>:</h4>
<p>it's basically helping inference along by asserting the return type at the end of the call</p>



<a name="262361774"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262361774" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262361774">(Nov 22 2021 at 18:52)</a>:</h4>
<p>Yeah. Inference basically refuses to work on abstract types</p>



<a name="262361901"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262361901" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262361901">(Nov 22 2021 at 18:53)</a>:</h4>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">Core</span><span class="o">.</span><span class="n">Compiler</span><span class="o">.</span><span class="n">return_type</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Real</span><span class="p">})</span>

<span class="c">#+RESULTS:</span>
<span class="o">:</span> <span class="kt">Any</span>
</code></pre></div>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">Core</span><span class="o">.</span><span class="n">Compiler</span><span class="o">.</span><span class="n">return_type</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Real</span><span class="p">})</span>

<span class="c">#+RESULTS:</span>
<span class="o">:</span> <span class="kt">Real</span>
</code></pre></div>



<a name="262361917"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262361917" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262361917">(Nov 22 2021 at 18:53)</a>:</h4>
<p>There's no magic happening here</p>



<a name="262362031"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262362031" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262362031">(Nov 22 2021 at 18:54)</a>:</h4>
<p>In fact, you can even just lie to the compiler this way:</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="n">Core</span><span class="o">.</span><span class="n">Compiler</span><span class="o">.</span><span class="n">return_type</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">::</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Real</span><span class="p">,</span> <span class="kt">Real</span><span class="p">})</span>

<span class="c">#+RESULTS:</span>
<span class="o">:</span> <span class="kt">String</span>
</code></pre></div>



<a name="262362134"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262362134" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262362134">(Nov 22 2021 at 18:55)</a>:</h4>
<p>yup</p>



<a name="262362173"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262362173" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262362173">(Nov 22 2021 at 18:56)</a>:</h4>
<p>inference can't really know what <code>Real + Real</code> would be - they can't be instantiated after all</p>



<a name="262362269"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262362269" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262362269">(Nov 22 2021 at 18:56)</a>:</h4>
<p>imo that's a good thing, because I think that makes the trail you have to go search for until you find the instability much shorter</p>



<a name="262362428"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262362428" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262362428">(Nov 22 2021 at 18:58)</a>:</h4>
<p>This is why I think that type classes could be a potentially useful thing in julia even though we already have multiple dispatch. Besides being one way of expressing traits, they also allow you to express abstract type inference because they're more structured</p>



<a name="262367571"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262367571" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262367571">(Nov 22 2021 at 19:37)</a>:</h4>
<p>I just want to properly express that a thing is iterable AND indexable in the type system</p>



<a name="262367683"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262367683" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262367683">(Nov 22 2021 at 19:38)</a>:</h4>
<p>but without necessarily having it be <code>&lt;: AbstractArray</code> (non-rectangular and all that)</p>



<a name="262367734"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262367734" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sukera <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262367734">(Nov 22 2021 at 19:39)</a>:</h4>
<p>really, <code>AbstractArray</code> should just mean <code>Indexable</code>, <code>Iterable</code> and <code>Rectangular</code></p>



<a name="262369995"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/262369995" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#262369995">(Nov 22 2021 at 19:59)</a>:</h4>
<p>Yeah, I  mostly use <a href="https://github.com/search?q=Tricks.jl&amp;type=Repositories">Tricks.jl</a> to test for iterability, but it would be much better to have it built in and fast</p>



<a name="264007088"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/264007088" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chad Scherrer <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#264007088">(Dec 07 2021 at 14:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="269150">Mason Protter</span> <a href="#narrow/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures/near/262358928">said</a>:</p>
<blockquote>
<p>no idea if this is useful to you but you can always do this sort of pattern:</p>
<p><div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="k">struct</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span> <span class="o">&lt;:</span> <span class="kt">Tuple</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span>
    <span class="n">f</span><span class="o">::</span><span class="kt">F</span>
<span class="k">end</span>

<span class="n">MethodWrapper</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">F</span><span class="p">,</span> <span class="n">Ts</span><span class="p">)</span>  <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">}</span>           <span class="o">=</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">toTuple</span><span class="p">(</span><span class="kt">Ts</span><span class="p">),</span> <span class="kt">Any</span><span class="p">}(</span><span class="n">f</span><span class="p">)</span>
<span class="n">MethodWrapper</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">F</span><span class="p">,</span> <span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">::</span><span class="kt">Pair</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">}</span> <span class="o">=</span> <span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">toTuple</span><span class="p">(</span><span class="kt">Ts</span><span class="p">),</span>   <span class="kt">R</span><span class="p">}(</span><span class="n">f</span><span class="p">)</span>
<span class="n">toTuple</span><span class="p">(</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">T</span><span class="p">})</span> <span class="k">where</span> <span class="p">{</span><span class="kt">T</span><span class="p">}</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">T</span><span class="p">}</span>
<span class="n">toTuple</span><span class="p">(</span><span class="n">Ts</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">{</span><span class="kt">Ts</span><span class="o">...</span><span class="p">}</span>

<span class="p">(</span><span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">R</span><span class="p">})(</span>  <span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span><span class="o">::</span><span class="kt">R</span>
<span class="p">(</span><span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">,</span> <span class="kt">Any</span><span class="p">})(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Ts</span><span class="p">}</span>    <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>

<span class="k">function</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="kt">IO</span><span class="p">,</span> <span class="n">M</span><span class="o">::</span><span class="kt">MethodWrapper</span><span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span><span class="p">,</span> <span class="kt">R</span><span class="p">})</span> <span class="k">where</span> <span class="p">{</span><span class="kt">F</span><span class="p">,</span> <span class="kt">T</span> <span class="o">&lt;:</span> <span class="kt">Tuple</span><span class="p">,</span> <span class="kt">R</span><span class="p">}</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="s">"(::</span><span class="si">$</span><span class="p">(</span><span class="n">Ts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="s">", ::</span><span class="si">$</span><span class="p">(</span><span class="n">Ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="s">"</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">Ts</span><span class="p">))</span><span class="o">...</span><span class="p">,</span> <span class="s">")::</span><span class="si">$R</span><span class="s">"</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">macro</span> <span class="n">method</span><span class="p">(</span><span class="n">ex</span><span class="o">::</span><span class="kt">Expr</span><span class="p">)</span>
    <span class="nd">@assert</span> <span class="n">ex</span><span class="o">.</span><span class="n">head</span> <span class="o">∈</span> <span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="ss">:call</span>
        <span class="n">R</span> <span class="o">=</span> <span class="kt">Any</span>
    <span class="k">else</span>
        <span class="n">R</span>  <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="p">])</span> <span class="k">do</span> <span class="n">arg</span><span class="o">::</span><span class="kt">Expr</span>
        <span class="nd">@assert</span> <span class="n">arg</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">)</span>
        <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">length</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">)]</span>
    <span class="k">end</span>
    <span class="n">esc</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="n">MethodWrapper</span><span class="p">(</span><span class="o">$</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="kt">Tuple</span><span class="p">(</span><span class="n">Ts</span><span class="p">)</span><span class="o">...</span><span class="p">),)</span> <span class="o">=&gt;</span> <span class="o">$</span><span class="n">R</span><span class="p">)))</span>
<span class="k">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p><span class="user-mention" data-user-id="269150">@Mason Protter</span> have you considered making this into a package? I think lots of people use <a href="https://github.com/search?q=FunctionWrappers.jl&amp;type=Repositories">FunctionWrappers.jl</a> to solve this problem, but that adds a lot of overhead. <a href="https://github.com/search?q=Catlab.jl&amp;type=Repositories">Catlab.jl</a> is one example:<br>
<a href="https://github.com/AlgebraicJulia/Catlab.jl/issues/586#issuecomment-987502657">https://github.com/AlgebraicJulia/Catlab.jl/issues/586#issuecomment-987502657</a><br>
<span class="user-mention" data-user-id="278517">@Evan Patterson</span> <span class="user-mention" data-user-id="270680">@James Fairbanks</span></p>



<a name="264027073"></a>
<h4><a href="https://julialang.zulipchat.com#narrow/stream/274208-helpdesk%20%28published%29/topic/Constraining%20method%20signatures/near/264027073" class="zl"><img src="https://juliacommunity.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Protter <a href="https://juliacommunity.github.io/zulip-archive/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures.html#264027073">(Dec 07 2021 at 16:33)</a>:</h4>
<p>Yeah I could stick it in a package if people would find it helpful.</p>



<hr><p>Last updated: Mar 02 2026 at 05:32 UTC</p>
</html>