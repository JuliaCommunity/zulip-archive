[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n\n<p>Not exactly a dilemma, but more of an open-ended question around package extensions (or maybe just package interaction in general) and how to think about APIs then.</p>\n<p>Suppose I have a package <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulation\">CarSimulation.jl</a> (actual project is not for cars, but this hopefully makes it easier to understand what I’m after) which comes with a few built-in cars so that users can do things like</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">CarModels</span><span class=\"o\">.</span><span class=\"n\">TypicalSemiTruck</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Where the whole point of <code>CarModels</code> is that users can type it in the REPL and then use tab to autocomplete and list available models.</p>\n<p>I now learned that there is a database where I can get accurate parameters for real car models and I’d like to integrate that <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulation\">CarSimulation.jl</a>.</p>\n<p>I could of course do something like this</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">fetch_from_database</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">“Honda</span><span class=\"w\"> </span><span class=\"n\">Civic”</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">year</span><span class=\"o\">=…</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>But that would lose the nice autocomplete properties. I would much rather have something like</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">CarModels</span><span class=\"o\">.</span><span class=\"n\">HondaCivic</span><span class=\"p\">(</span><span class=\"n\">year</span><span class=\"o\">=…</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This would make the integration seamless and the autocomplete workflow will still work.  Question is basically how best to accomplish this.</p>\n<p>The first things that some to mind is to generate structs based on entries in the database into a module called CarModels.</p>\n<p>One complication is that since database is optional (maybe users don’t even have access) I don’t want to add the database stuff directly to <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulations\">CarSimulations.jl</a>. The nicest would be to have an extension since I will anyway be creating a package for just the interaction with the database since this is needed in other contexts. </p>\n<p>However, extensions tend to be quite insulated from the main package (and probably for good reasons) and seem to mostly want to work with types owned by the extended package. I guess trying to eval stuff into the parent package is asking for trouble (if it even works at all)?</p>\n<p>Another option could be to make CarModels an constant instance of some struct (which might need some pretty convoluted implementations of getproperty to make the syntax above work) which the extension modifies when initialized. Or is this almost as bad as the above?</p>\n<p>Last resort option I can think of is to compromise a bit and have something like <code>DataBaseCarModels.HondaCivic</code> in the database package as some struct which just wraps the database output and then let the extension (in <code>CarSimulation.jl</code>) translate the database output into some generic <code>CarModel</code> which the <code>CarSimulations.jl</code> code can work with. </p>\n<p>This is probably perfectly fine from the user perspective, but I’m worried about the maintenance since <code>CarSimulation.jl</code> exports a quite large number of functions which take a car model as input which all would need to be implemented for the wrapped database output. </p>\n<p>Having a function to convert a database struct to a <code>CarModel</code> could alleviate this maintenance burden at the cost of user inconvenience. This also create the dilemma of where the conversion function shall live, but I suppose it could be owned by <code>CarSimulations.jl</code> and just default to an error.</p>\n<p>A to me much less attractive last resort option I can think of is to have a combination package (<code>DataBaseCarSimulation.jl</code>) which depends on both <code>CarSimulation</code> and the database package. I guess this would allow <code>DataBaseCarModels</code> to have autocompletable car models on the format which <code>CarSimulation.jl</code> expects. Maybe this is actually the idiomatic solution to this problem? I’d still like to avoid it if possible, but I won’t die on that hill.</p>",
        "id": 548126163,
        "sender_full_name": "DrChainsaw",
        "timestamp": 1761907734
    },
    {
        "content": "<p>Can you show the base setup of this in code - is <code>CarModels</code> a module? What type is <code>TypicalSemiTruck</code>? (Maybe you're rethinking those in the face of this database idea, but understanding the original structure you were thinking of without that would still help understand the context better.)</p>\n<p>Btw, dictionaries also get auto-complete in the REPL, so that might be a convenient option here.</p>",
        "id": 548233915,
        "sender_full_name": "Sundar R",
        "timestamp": 1761939717
    },
    {
        "content": "<blockquote>\n<p>Can you show the base setup of this in code - is <code>CarModels</code> a module? What type is <code>TypicalSemiTruck</code>?</p>\n</blockquote>\n<p>Yeah, at the moment <code>CarModels</code> is a baremodule (just so it does not show anything except the things I have decalared in it) and <code>TypicalSemiTruck</code> is a type (which just wraps a few generic parameter containing other structs), but the only reason for this design is to get the auto-complete discovery aspect.</p>\n<p>I am indeed rethinking the design as I would assume that eval-ing stuff into <code>CarModels</code> from a package extension is not a workable design.</p>\n<p>I didn't know dicts auto-complete. It would make a simpler version of the second option I thought ot. That could very well be the simplest option then.</p>",
        "id": 548236727,
        "sender_full_name": "DrChainsaw",
        "timestamp": 1761940685
    },
    {
        "content": "<p>In my view it would be better to have your own CarModels and the DatabaseCarModels as separate objects instead of having DatabaseCarModels optionally hide inside CarModels. This gives you the freedom of not having to maintain a possible abstraction layer between the two if they ever diverge in their api, which sounds as a decent headache. </p>\n<p>You could define DatabaseCarModels as a struct and play around with Base.propertynames for the tab completion and Base.getproperty for retrieving the models.</p>\n<p>If you want “callable” properties, it might be a bit tricky, it would probably need you to generate functor stubs of all the database models in the extension, which could be done with, admittedly, a probably rather involved macro.<br>\nBut at that point you can have the translation happen automatically in the functor.</p>\n<p>P.S.: apologies for the unformatted code, Zulip on mobile is a disgrace</p>",
        "id": 554151141,
        "sender_full_name": "cschen",
        "timestamp": 1762450432
    },
    {
        "content": "<p>Thanks,</p>\n<p>I think I've come to the same conclusion w.r.t the namespace separation. </p>\n<p>It was perhaps a bit obscured in the question, but a big part of what I'm struggling with is a good way to cross the mainpackage - extension border. For example, it seems as if DatabaseCarModels would either need to be owned by the main package and created as a global empty instance or returned through a function call which the main package owns (and the extension implements a method which takes some type owned by the extended package).</p>\n<p>For now I have used the latter method so there is an empty generate_carmodels function in the main package which the extension implements. I made the database package just wrap all the downloaded data in structs so that it has own types which can be used for this dispatch.</p>\n<p>All in all I'm not too unhappy about this. </p>\n<p>I couldn't really let go of how nice it would be (from the end users perspective) to have the database models as types, so for now this function returns an expression which the main package evals to create DatabaseCarModels as a submodule to the main package, although I do have a feeling I will regret this choice soon. The logic to handle the database output is quite generic though so it should not be too much effort to change it so it just returns some collection of non-unique-type instances.</p>",
        "id": 554165268,
        "sender_full_name": "DrChainsaw",
        "timestamp": 1762454746
    }
]