[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n\n<p>Not exactly a dilemma, but more of an open-ended question around package extensions (or maybe just package interaction in general) and how to think about APIs then.</p>\n<p>Suppose I have a package <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulation\">CarSimulation.jl</a> (actual project is not for cars, but this hopefully makes it easier to understand what I’m after) which comes with a few built-in cars so that users can do things like</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">CarModels</span><span class=\"o\">.</span><span class=\"n\">TypicalSemiTruck</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Where the whole point of <code>CarModels</code> is that users can type it in the REPL and then use tab to autocomplete and list available models.</p>\n<p>I now learned that there is a database where I can get accurate parameters for real car models and I’d like to integrate that <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulation\">CarSimulation.jl</a>.</p>\n<p>I could of course do something like this</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">fetch_from_database</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">“Honda</span><span class=\"w\"> </span><span class=\"n\">Civic”</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">year</span><span class=\"o\">=…</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>But that would lose the nice autocomplete properties. I would much rather have something like</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">crashtest</span><span class=\"p\">(</span><span class=\"n\">CarModels</span><span class=\"o\">.</span><span class=\"n\">HondaCivic</span><span class=\"p\">(</span><span class=\"n\">year</span><span class=\"o\">=…</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"n\">kmh</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This would make the integration seamless and the autocomplete workflow will still work.  Question is basically how best to accomplish this.</p>\n<p>The first things that some to mind is to generate structs based on entries in the database into a module called CarModels.</p>\n<p>One complication is that since database is optional (maybe users don’t even have access) I don’t want to add the database stuff directly to <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/CarSimulations\">CarSimulations.jl</a>. The nicest would be to have an extension since I will anyway be creating a package for just the interaction with the database since this is needed in other contexts. </p>\n<p>However, extensions tend to be quite insulated from the main package (and probably for good reasons) and seem to mostly want to work with types owned by the extended package. I guess trying to eval stuff into the parent package is asking for trouble (if it even works at all)?</p>\n<p>Another option could be to make CarModels an constant instance of some struct (which might need some pretty convoluted implementations of getproperty to make the syntax above work) which the extension modifies when initialized. Or is this almost as bad as the above?</p>\n<p>Last resort option I can think of is to compromise a bit and have something like <code>DataBaseCarModels.HondaCivic</code> in the database package as some struct which just wraps the database output and then let the extension (in <code>CarSimulation.jl</code>) translate the database output into some generic <code>CarModel</code> which the <code>CarSimulations.jl</code> code can work with. </p>\n<p>This is probably perfectly fine from the user perspective, but I’m worried about the maintenance since <code>CarSimulation.jl</code> exports a quite large number of functions which take a car model as input which all would need to be implemented for the wrapped database output. </p>\n<p>Having a function to convert a database struct to a <code>CarModel</code> could alleviate this maintenance burden at the cost of user inconvenience. This also create the dilemma of where the conversion function shall live, but I suppose it could be owned by <code>CarSimulations.jl</code> and just default to an error.</p>\n<p>A to me much less attractive last resort option I can think of is to have a combination package (<code>DataBaseCarSimulation.jl</code>) which depends on both <code>CarSimulation</code> and the database package. I guess this would allow <code>DataBaseCarModels</code> to have autocompletable car models on the format which <code>CarSimulation.jl</code> expects. Maybe this is actually the idiomatic solution to this problem? I’d still like to avoid it if possible, but I won’t die on that hill.</p>",
        "id": 548126163,
        "sender_full_name": "DrChainsaw",
        "timestamp": 1761907734
    },
    {
        "content": "<p>Can you show the base setup of this in code - is <code>CarModels</code> a module? What type is <code>TypicalSemiTruck</code>? (Maybe you're rethinking those in the face of this database idea, but understanding the original structure you were thinking of without that would still help understand the context better.)</p>\n<p>Btw, dictionaries also get auto-complete in the REPL, so that might be a convenient option here.</p>",
        "id": 548233915,
        "sender_full_name": "Sundar R",
        "timestamp": 1761939717
    },
    {
        "content": "<blockquote>\n<p>Can you show the base setup of this in code - is <code>CarModels</code> a module? What type is <code>TypicalSemiTruck</code>?</p>\n</blockquote>\n<p>Yeah, at the moment <code>CarModels</code> is a baremodule (just so it does not show anything except the things I have decalared in it) and <code>TypicalSemiTruck</code> is a type (which just wraps a few generic parameter containing other structs), but the only reason for this design is to get the auto-complete discovery aspect.</p>\n<p>I am indeed rethinking the design as I would assume that eval-ing stuff into <code>CarModels</code> from a package extension is not a workable design.</p>\n<p>I didn't know dicts auto-complete. It would make a simpler version of the second option I thought ot. That could very well be the simplest option then.</p>",
        "id": 548236727,
        "sender_full_name": "DrChainsaw",
        "timestamp": 1761940685
    }
]