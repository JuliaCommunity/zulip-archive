[
    {
        "content": "<p>I'm trying to make a recursive type for a bifurcating tree with edge lengths. I'm not sure which would be more efficient or easier to handle afterwards. I've come with two options:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">mutable struct</span> <span class=\"kt\">Tree</span>\n  <span class=\"n\">d1</span><span class=\"o\">::</span><span class=\"kt\">Tree</span>\n  <span class=\"n\">d2</span><span class=\"o\">::</span><span class=\"kt\">Tree</span>\n  <span class=\"n\">edge</span><span class=\"o\">::</span><span class=\"kt\">Float64</span>\n  <span class=\"n\">Tree</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">();</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">d1</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">d2</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">,)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">mutable struct</span> <span class=\"kt\">Tree</span>\n  <span class=\"n\">d1</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n  <span class=\"n\">d2</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n  <span class=\"n\">edge</span><span class=\"o\">::</span><span class=\"kt\">Float64</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Any thoughts on which one is better?</p>",
        "id": 246823253,
        "sender_full_name": "Ignacio Quintero",
        "timestamp": 1626944469
    },
    {
        "content": "<p>In my experience<code>Union{Tree, Nothing}</code> is better (note that you should use <code>Nothing</code> as a type, not <code>nothing</code> which is variable).</p>\n<p>EDITED: This is wrong, as it was explained in the thread later.</p>",
        "id": 246823379,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626944549
    },
    {
        "content": "<p>It is better from performance point of view: <code>isdefined(tree, :d1)</code> take longer, then <code>tree.d1 === nothing</code>.</p>",
        "id": 246823447,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626944606
    },
    {
        "content": "<blockquote>\n<p>It is better from performance point of view: <code>isdefined(tree, :d1)</code> take longer, then <code>tree.d1 === nothing</code>.</p>\n</blockquote>\n<p>Are you sure about that? That would surprise me, I wouldn't expect any big performance differences between both approaches. It also doesn't seem like <code>isdefined</code> will be used in the first example at all, but instead the end of the list is denoted by arriving at the original node again.</p>",
        "id": 246824186,
        "sender_full_name": "Simeon Schaub",
        "timestamp": 1626945183
    },
    {
        "content": "<p>Well, some time ago I've benchmarked these things.<br>\nMaybe something has changed, idk.</p>\n<p>And yes, you are right in this case there will be no validation for nothingness of the leaf, but as a rule of thumb, I prefer to follow one strategy always.</p>\n<p>And anyway, working with types is more consistent, than switching between <code>x.field</code> and <code>isdefined(x, :field)</code> notation.</p>",
        "id": 246824530,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626945458
    },
    {
        "content": "<p>Hmmm... It's hard to measure properly, so probably my benchmarks are wrong.</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">Tree1</span>\n    <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n    <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n\n    <span class=\"n\">Tree1</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">struct</span> <span class=\"kt\">Tree2</span>\n    <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree2</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n    <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree2</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n<span class=\"k\">end</span>\n<span class=\"n\">Tree2</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"n\">Tree2</span><span class=\"p\">(</span><span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"nb\">nothing</span><span class=\"p\">)</span>\n\n<span class=\"n\">leftleaf</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">isdefined</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"ss\">:l</span><span class=\"p\">)</span>\n<span class=\"n\">leftleaf</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Tree2</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">l</span> <span class=\"o\">!==</span> <span class=\"nb\">nothing</span>\n\n<span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Tree1</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">10000</span><span class=\"p\">]</span>\n<span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Tree2</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">10000</span><span class=\"p\">]</span>\n\n<span class=\"nd\">@btime</span> <span class=\"n\">leftleaf</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">t1</span><span class=\"p\">);</span>\n<span class=\"c\">#  11.222 μs (3 allocations: 5.55 KiB)</span>\n\n<span class=\"nd\">@btime</span> <span class=\"n\">leftleaf</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">t2</span><span class=\"p\">);</span>\n<span class=\"c\">#  8.423 μs (3 allocations: 5.55 KiB)</span>\n</code></pre></div>\n<p>Well, probably it's just interaction between broadcasting and <code>=== nothing</code> operations, but in real world, we always have some complicated interaction. Overall, I saw that <code>isdefined</code> is slower in real world applications in a situations when I have lots of operations with nodes.</p>",
        "id": 246825300,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626946032
    },
    {
        "content": "<p>I mean it's hard to see the difference with a single operation, since it take ~1ns and difference is lost in the noise.</p>",
        "id": 246825485,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626946174
    },
    {
        "content": "<p>Thanks so much for this! So just to add, I need to do many iterations like transversing the tree and so forth, and according to the following very simple example, it would seem faster to transverse over the undefined type to estimate, say, the tree length:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">mutable struct</span> <span class=\"kt\">Tree1</span>\n    <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n    <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n    <span class=\"n\">e</span><span class=\"o\">::</span><span class=\"kt\">Float64</span>\n    <span class=\"n\">Tree1</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">()</span>\n    <span class=\"n\">Tree1</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">mutable struct</span> <span class=\"kt\">Tree2</span>\n    <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree2</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n    <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">Tree2</span><span class=\"p\">,</span> <span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n    <span class=\"n\">e</span><span class=\"o\">::</span><span class=\"kt\">Float64</span>\n<span class=\"k\">end</span>\n<span class=\"n\">Tree2</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"n\">Tree2</span><span class=\"p\">(</span><span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>\n\n<span class=\"k\">using</span> <span class=\"n\">BenchmarkTools</span>\n\n<span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">Tree1</span><span class=\"p\">(</span><span class=\"n\">Tree1</span><span class=\"p\">(),</span> <span class=\"n\">Tree1</span><span class=\"p\">(),</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">Tree2</span><span class=\"p\">(</span><span class=\"n\">Tree2</span><span class=\"p\">(</span><span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">),</span> <span class=\"n\">Tree2</span><span class=\"p\">(</span><span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"nb\">nothing</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">),</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n\n<span class=\"k\">function</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"p\">)</span>\n  <span class=\"n\">l</span> <span class=\"o\">+=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">e</span>\n  <span class=\"k\">if</span> <span class=\"n\">isdefined</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"ss\">:l</span><span class=\"p\">)</span>\n    <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n  <span class=\"k\">if</span> <span class=\"n\">isdefined</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"ss\">:r</span><span class=\"p\">)</span>\n   <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n  <span class=\"k\">return</span> <span class=\"n\">l</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Tree2</span><span class=\"p\">)</span> <span class=\"o\">=</span>\n  <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">e</span> <span class=\"o\">+</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Nothing</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>\n\n<span class=\"nd\">@benchmark</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>\n  <span class=\"c\"># memory estimate:  0 bytes</span>\n  <span class=\"c\"># allocs estimate:  0</span>\n  <span class=\"c\"># --------------</span>\n  <span class=\"c\"># minimum time:     6.327 ns (0.00% GC)</span>\n  <span class=\"c\"># median time:      6.357 ns (0.00% GC)</span>\n  <span class=\"c\"># mean time:        6.731 ns (0.00% GC)</span>\n  <span class=\"c\"># maximum time:     91.463 ns (0.00% GC)</span>\n  <span class=\"c\"># --------------</span>\n  <span class=\"c\"># samples:          10000</span>\n  <span class=\"c\"># evals/sample:     1000</span>\n\n<span class=\"nd\">@benchmark</span> <span class=\"n\">treelength</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">t2</span><span class=\"p\">)</span>\n  <span class=\"c\"># memory estimate:  0 bytes</span>\n  <span class=\"c\"># allocs estimate:  0</span>\n  <span class=\"c\"># --------------</span>\n  <span class=\"c\"># minimum time:     7.770 ns (0.00% GC)</span>\n  <span class=\"c\"># median time:      8.024 ns (0.00% GC)</span>\n  <span class=\"c\"># mean time:        8.700 ns (0.00% GC)</span>\n  <span class=\"c\"># maximum time:     113.810 ns (0.00% GC)</span>\n  <span class=\"c\"># --------------</span>\n  <span class=\"c\"># samples:          10000</span>\n  <span class=\"c\"># evals/sample:     999</span>\n</code></pre></div>",
        "id": 246829340,
        "sender_full_name": "Ignacio Quintero",
        "timestamp": 1626948968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"272583\">Simeon Schaub</span> <a href=\"#narrow/stream/274208-helpdesk-.28published.29/topic/Recursive.20Types/near/246824186\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It is better from performance point of view: <code>isdefined(tree, :d1)</code> take longer, then <code>tree.d1 === nothing</code>.</p>\n</blockquote>\n<p>Are you sure about that? That would surprise me, I wouldn't expect any big performance differences between both approaches. It also doesn't seem like <code>isdefined</code> will be used in the first example at all, but instead the end of the list is denoted by arriving at the original node again.</p>\n</blockquote>\n<p>Yeah, so in the first case, one can test one arrived at leaf simply by <code>===</code>  with one of the daughters?</p>",
        "id": 246829738,
        "sender_full_name": "Ignacio Quintero",
        "timestamp": 1626949309
    },
    {
        "content": "<p>One final question, how do you start a Constructor for the undefined Type where one creates a new object with undefined recursive types but an <code>e = x</code> argument?<br>\nSomething like <code>Tree1(e::Float64) = new(l, r, e)</code>(but that works...)</p>",
        "id": 246831014,
        "sender_full_name": "Ignacio Quintero",
        "timestamp": 1626950205
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">Tree1</span>\n    <span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n    <span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Tree1</span>\n\n    <span class=\"n\">Tree1</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>I think that's kind of wild because you can't edit <code>l</code> or <code>r</code> without pointer stuff. Maybe you meant to say <code>mutable</code>?</p>\n<p><span class=\"user-mention\" data-user-id=\"339377\">@Ignacio Quintero</span>  You might want to look at <a href=\"https://github.com/search?q=LinkedList.jl&amp;type=Repositories\">LinkedList.jl</a> and <a href=\"https://github.com/search?q=DataStructures.jl&amp;type=Repositories\">DataStructures.jl</a>   One of them takes the approach of Nil nodes and the other defines a leaf by checking if the <code>next</code> pointer is pointing to itself. Either way is fine.</p>",
        "id": 246844108,
        "sender_full_name": "Colin Caine",
        "timestamp": 1626959481
    },
    {
        "content": "<p>Haha, you right! Of course it should be <code>mutable</code> and then difference is not that big.</p>\n<p>Anyway, it looks like I should reconsider my own advice :-) It seems that <code>Union</code> version is worse than <code>undef</code> or even better cycled pointers.</p>",
        "id": 246844601,
        "sender_full_name": "Kwaku Oskin",
        "timestamp": 1626959743
    }
]