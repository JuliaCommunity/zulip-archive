[
    {
        "content": "<p>Considering this function, which I've just moved from a recursive design to <br>\nan iterative paradigm</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"kd\">const</span> <span class=\"n\">Sub</span> <span class=\"o\">=</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">ImmutableDict</span><span class=\"p\">{</span><span class=\"kt\">Any</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"n\">EClass</span><span class=\"p\">,</span> <span class=\"kt\">Any</span><span class=\"p\">}}</span>\n<span class=\"kd\">const</span> <span class=\"n\">SubBuf</span> <span class=\"o\">=</span> <span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"n\">Sub</span><span class=\"p\">}</span>\n\n<span class=\"c\"># https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf</span>\n<span class=\"c\"># page 48</span>\n<span class=\"s\">\"\"\"</span>\n<span class=\"s\">From [https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf](https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf)</span>\n<span class=\"s\">The iterator `ematchlist` matches a list of terms `t` to a list of E-nodes by first finding</span>\n<span class=\"s\">all substitutions that match the first term to the first E-node, and then extending</span>\n<span class=\"s\">each such substitution in all possible ways that match the remaining terms to</span>\n<span class=\"s\">the remaining E-nodes. The base case of this recursion is the empty list, which</span>\n<span class=\"s\">requires no extension to the substitution; the other case relies on Match to find the</span>\n<span class=\"s\">substitutions that match the first term to the first E-node.</span>\n<span class=\"s\">\"\"\"</span>\n<span class=\"k\">function</span> <span class=\"n\">ematchlist</span><span class=\"p\">(</span><span class=\"nb\">e</span><span class=\"o\">::</span><span class=\"n\">EGraph</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">AbstractVector</span><span class=\"p\">{</span><span class=\"n\">Pattern</span><span class=\"p\">},</span> <span class=\"n\">v</span><span class=\"o\">::</span><span class=\"kt\">AbstractVector</span><span class=\"p\">{</span><span class=\"kt\">Int64</span><span class=\"p\">},</span> <span class=\"n\">sub</span><span class=\"o\">::</span><span class=\"n\">Sub</span><span class=\"p\">,</span> <span class=\"n\">buf</span><span class=\"o\">::</span><span class=\"n\">SubBuf</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"n\">SubBuf</span>\n    <span class=\"n\">lt</span> <span class=\"o\">=</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n    <span class=\"n\">lv</span> <span class=\"o\">=</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span>\n\n    <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">lt</span> <span class=\"o\">==</span> <span class=\"n\">lv</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"k\">return</span> <span class=\"n\">buf</span><span class=\"p\">)</span>\n\n    <span class=\"c\"># currbuf = buf</span>\n    <span class=\"n\">currbuf</span> <span class=\"o\">=</span> <span class=\"n\">SubBuf</span><span class=\"p\">()</span>\n    <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">currbuf</span><span class=\"p\">,</span> <span class=\"n\">sub</span><span class=\"p\">)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">∈</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">lt</span>\n        <span class=\"n\">newbuf</span> <span class=\"o\">=</span> <span class=\"n\">SubBuf</span><span class=\"p\">()</span>\n        <span class=\"k\">while</span> <span class=\"o\">!</span><span class=\"n\">isempty</span><span class=\"p\">(</span><span class=\"n\">currbuf</span><span class=\"p\">)</span>\n            <span class=\"n\">currsub</span> <span class=\"o\">=</span> <span class=\"n\">pop!</span><span class=\"p\">(</span><span class=\"n\">currbuf</span><span class=\"p\">)</span>\n            <span class=\"n\">ematchstep</span><span class=\"p\">(</span><span class=\"nb\">e</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">v</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">currsub</span><span class=\"p\">,</span> <span class=\"n\">newbuf</span><span class=\"p\">,</span> <span class=\"nb\">nothing</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n        <span class=\"n\">currbuf</span> <span class=\"o\">=</span> <span class=\"n\">newbuf</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">sub1</span> <span class=\"o\">∈</span> <span class=\"n\">currbuf</span>\n        <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">sub1</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">buf</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Allocating new buffers every time is expensive, and I have basically no performance gain from the recursive version. How can I optimize this loop, removing unnecessary \"buffer creations\", knowing that i have my output <code>buf</code> already waiting to be \"push!-ed\" ? A thing worth noting is that the subcall to <code>ematchstep</code> pushes new elements to <code>newbuf</code>.</p>",
        "id": 232411905,
        "sender_full_name": "Alessandro Cheli",
        "timestamp": 1617105027
    }
]