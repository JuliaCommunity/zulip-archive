[
    {
        "content": "<p>The following code is unsafe (or the result is undefined) in general because the loop variable <code>i</code> may be changed when a new task is spawned and run:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">using</span> <span class=\"o\">.</span><span class=\"n\">Threads</span><span class=\"o\">:</span> <span class=\"nd\">@spawn</span>\n<span class=\"k\">function</span> <span class=\"n\">loop</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"kt\">Task</span><span class=\"p\">[]</span>\n    <span class=\"nd\">@sync</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">n</span>\n        <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"p\">,</span> <span class=\"nd\">@spawn</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">fetch</span><span class=\"p\">,</span> <span class=\"n\">tasks</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Instead, we should interpolate the variable with <code>$</code> to copy the value, right?</p>",
        "id": 240434539,
        "sender_full_name": "Kenta Sato",
        "timestamp": 1622104184
    },
    {
        "content": "<p>You don't need interpolation in this case because the scope of <code>i</code> is inside the loop and <code>i</code> is never re-assigned. You'd have the problem if you are capturing variables that are re-assigned. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"k\">let</span> <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n           <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n           <span class=\"nd\">@sync</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">3</span>\n               <span class=\"n\">a</span> <span class=\"o\">+=</span> <span class=\"n\">i</span>\n               <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"p\">,</span> <span class=\"n\">Threads</span><span class=\"o\">.</span><span class=\"nd\">@spawn</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">))</span>\n           <span class=\"k\">end</span>\n           <span class=\"n\">fetch</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"p\">)</span>\n       <span class=\"k\">end</span>\n<span class=\"mi\">3</span><span class=\"o\">-</span><span class=\"n\">element</span> <span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Int64</span><span class=\"p\">,</span> <span class=\"kt\">Int64</span><span class=\"p\">}}</span><span class=\"o\">:</span>\n <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Using <code>$a</code> (or <code>let a = a ... end</code>) is a good solution here.</p>",
        "id": 240443231,
        "sender_full_name": "Takafumi Arakaki (tkf)",
        "timestamp": 1622109814
    },
    {
        "content": "<p>Thank you! So, we can think <code>i</code> as a variable that is newly generated for each iteration and therefore iterations have its own isolated variable. I need to update my mental model.</p>",
        "id": 240448308,
        "sender_full_name": "Kenta Sato",
        "timestamp": 1622112945
    },
    {
        "content": "<p>Exactly! This is actually how closures work in Julia. Task-creating macros like <code>@spawn</code> are just a thin syntax sugar on top of closures.</p>\n<p>I think it's easier to play with closures and figure out how it interacts with the scoping rule:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n       <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">3</span>\n           <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">fs</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n       <span class=\"k\">end</span>\n       <span class=\"p\">[</span><span class=\"n\">f</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"k\">in</span> <span class=\"n\">fs</span><span class=\"p\">]</span>\n<span class=\"mi\">3</span><span class=\"o\">-</span><span class=\"n\">element</span> <span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Int64</span><span class=\"p\">}</span><span class=\"o\">:</span>\n <span class=\"mi\">1</span>\n <span class=\"mi\">2</span>\n <span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 240540141,
        "sender_full_name": "Takafumi Arakaki (tkf)",
        "timestamp": 1622154547
    }
]