[
    {
        "content": "<p>How to be more type-specific than <code>::Function</code> when passing methods to methods (defining higher-order functions) or defining structs with methods as fields?</p>\n<p>Just use <a href=\"https://github.com/yuyichao/FunctionWrappers.jl\">https://github.com/yuyichao/FunctionWrappers.jl</a> ?</p>",
        "id": 262302620,
        "sender_full_name": "Jesper Stemann Andersen",
        "timestamp": 1637577550
    },
    {
        "content": "<p>why do you want to do that?</p>",
        "id": 262302844,
        "sender_full_name": "Sebastian Pfitzner",
        "timestamp": 1637577700
    },
    {
        "content": "<p>for structs with methods as fields I just use </p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">test</span><span class=\"p\">{</span><span class=\"kt\">A</span><span class=\"p\">}</span>\n<span class=\"n\">fun</span><span class=\"o\">::</span><span class=\"kt\">A</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>julia is then able to infer the exact fun, and keeps things type stable</p>",
        "id": 262303206,
        "sender_full_name": "Maarten",
        "timestamp": 1637577946
    },
    {
        "content": "<p>yeah, I was mostly asking about the first usecase</p>",
        "id": 262303463,
        "sender_full_name": "Sebastian Pfitzner",
        "timestamp": 1637578100
    },
    {
        "content": "<p>In a related thread, <span class=\"user-mention silent\" data-user-id=\"269150\">Mason Protter</span>: <a href=\"#narrow/stream/225542-helpdesk/topic/Methods.20of.20a.20function/near/203571606\">answers</a> that basically, this is not what you would do in Julia - you would prefer not to constrain the Function, as that would hinder the inter-operability of methods - i.e. \"dispatch nirvana\".</p>\n<p>But how do I explain to colleagues that their \"Pythonic\" or \"Csharpish\" way of doing things is not \"Julian\"? :-) A really strong point (in my memory) of the micro-benchmarks once highlighted was  \"you can write any sort of algorithm in Julia\". And indeed you can. But can I get type inference (and hence static type analysis) as well, please? :-)</p>\n<p>So use case: Inferrable types - code navigation etc.</p>",
        "id": 262304070,
        "sender_full_name": "Jesper Stemann Andersen",
        "timestamp": 1637578510
    },
    {
        "content": "<p>you use <code>where F</code></p>",
        "id": 262307439,
        "sender_full_name": "Sukera",
        "timestamp": 1637580845
    },
    {
        "content": "<p>see also <a href=\"https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing\">https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing</a></p>",
        "id": 262307497,
        "sender_full_name": "Sukera",
        "timestamp": 1637580891
    },
    {
        "content": "<p>in general <code>::T</code> in a function signature _does not generally improve performance or inferrability_ - it is mainly a tool for deciding dispatch</p>",
        "id": 262307567,
        "sender_full_name": "Sukera",
        "timestamp": 1637580940
    },
    {
        "content": "<p>this may be unfamiliar to people used to static languages like java or C# - julia is a dynamic (though compiled) language</p>",
        "id": 262307586,
        "sender_full_name": "Sukera",
        "timestamp": 1637580960
    },
    {
        "content": "<p>these things are not exclusive!</p>",
        "id": 262307648,
        "sender_full_name": "Sukera",
        "timestamp": 1637580991
    },
    {
        "content": "<p>Ah, I see, so in the following, <code>f2</code> enable more specialization than <code>f1</code>? </p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">f1</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">Function</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">f2</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"kt\">F</span> <span class=\"o\">&lt;:</span> <span class=\"kt\">Function</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>I can't quite see the difference:</p>\n<div class=\"codehilite\" data-code-language=\"Julia console\"><pre><span></span><code><span class=\"gp\">julia&gt;</span> <span class=\"p\">(</span><span class=\"nd\">@which</span> <span class=\"n\">f1</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">specializations</span>\n<span class=\"go\">svec(MethodInstance for f1(::typeof(sin), ::Float64), MethodInstance for f1(::typeof(sin), ::Int64), #undef, #undef, #undef, #undef, #undef, #undef)</span>\n\n<span class=\"gp\">julia&gt;</span> <span class=\"p\">(</span><span class=\"nd\">@which</span> <span class=\"n\">f2</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">specializations</span>\n<span class=\"go\">svec(MethodInstance for f2(::typeof(sin), ::Float64), MethodInstance for f2(::typeof(sin), ::Int64), #undef, #undef, #undef, #undef, #undef, #undef)</span>\n</code></pre></div>",
        "id": 262311045,
        "sender_full_name": "Jesper Stemann Andersen",
        "timestamp": 1637583504
    },
    {
        "content": "<p>I am actually not looking for performance - what I am seeking is inferability - to enable static analysis (whether by a human or JET). I would prefer to constrain the methods that will be accepted, such that my program is more expressive - more clear.</p>\n<p>Despite that \"Julian\"/dispatch-way of doing it, where \"it\" being a function <code>f</code> of two objects dependent on a distance measure, might be:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">abstract type</span> <span class=\"kt\">AbstractFoo</span> <span class=\"k\">end</span>\n\n<span class=\"k\">abstract type</span> <span class=\"kt\">AbstractFooDistance</span> <span class=\"k\">end</span>\n\n<span class=\"k\">struct</span> <span class=\"kt\">FooDistance1</span> <span class=\"k\">end</span>\n<span class=\"k\">struct</span> <span class=\"kt\">FooDistance2</span> <span class=\"k\">end</span>\n\n<span class=\"n\">dist</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">FooDistance1</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">dist</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">FooDistance2</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">AbstractFooDistance</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">dist</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>The  most common approach would be:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">abstract type</span> <span class=\"kt\">AbstractFoo</span> <span class=\"k\">end</span>\n\n<span class=\"n\">dist1</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">dist2</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">Function</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>which leaves <code>d</code> quite open.</p>\n<p>A <code>FunctionWrapper</code> seems to enable specifying the signature of accepted <code>d</code>'s:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"o\">::</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">FunctionWrapper</span><span class=\"p\">{</span><span class=\"kt\">Int</span><span class=\"p\">,(</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">)})</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... at the cost of having to wrap the functions at the call sites:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">foo1</span><span class=\"p\">,</span> <span class=\"n\">foo2</span><span class=\"p\">,</span> <span class=\"kt\">FunctionWrapper</span><span class=\"p\">{</span><span class=\"kt\">Int</span><span class=\"p\">,(</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">,</span><span class=\"kt\">AbstractFoo</span><span class=\"p\">)}(</span><span class=\"n\">dist1</span><span class=\"p\">))</span>\n</code></pre></div>",
        "id": 262312064,
        "sender_full_name": "Jesper Stemann Andersen",
        "timestamp": 1637584207
    },
    {
        "content": "<blockquote>\n<p>I can't quite see the difference:</p>\n</blockquote>\n<p>See:</p>\n<blockquote>\n<p>Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function.</p>\n</blockquote>",
        "id": 262314015,
        "sender_full_name": "Sukera",
        "timestamp": 1637585419
    },
    {
        "content": "<p>it will still infer correctly, it just may not need to specialize</p>",
        "id": 262314053,
        "sender_full_name": "Sukera",
        "timestamp": 1637585453
    },
    {
        "content": "<p>i.e. the differently inferred methods may point to the same non-specialized code</p>",
        "id": 262314093,
        "sender_full_name": "Sukera",
        "timestamp": 1637585478
    },
    {
        "content": "<p>unless you really need <code>FunctionWrappers</code>, I wouldn't start with it in mind</p>",
        "id": 262314218,
        "sender_full_name": "Sukera",
        "timestamp": 1637585526
    },
    {
        "content": "<p>in general, julia style seems to be shallower type hierarchies, in contrast to e.g. Java or C#, where very deeply nested type hierarchies are common</p>",
        "id": 262314293,
        "sender_full_name": "Sukera",
        "timestamp": 1637585567
    },
    {
        "content": "<p>one reason for this is that abstract types don't hold state, i.e. there is no structural inheritance</p>",
        "id": 262314366,
        "sender_full_name": "Sukera",
        "timestamp": 1637585625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306754\">Sukera</span> <a href=\"#narrow/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures/near/262314218\">said</a>:</p>\n<blockquote>\n<p>unless you really need <code>FunctionWrappers</code>, I wouldn't start with it in mind</p>\n</blockquote>\n<p>We don't - I prefer to define the distance types and let dispatch handle it - i.e., avoiding <code>::Function</code>. It was more for sake of argument - saying \"you shouldn't do it like that - that's not the way it should be done in Julia\" doesn't feel like a strong argument.</p>",
        "id": 262319105,
        "sender_full_name": "Jesper Stemann Andersen",
        "timestamp": 1637588280
    },
    {
        "content": "<p>This sounds related to a problem I've run into a few times. If you pass <code>f</code> as a function (generically or <code>::Function</code>) you usually can't know anything statically about the function.</p>\n<p>It's often useful to know \"this function returns a function\" or \"this function returns a lower-triangular matrix of Float64s\". Ideally, there could even be a way to dispatch on things like this. But Julia isn't set up this way. For dispatch, you can only do <code>::Function</code> or <code>::typeof(f)</code>. You either know nothing or everything, there's no in between. So you're often stuck with just running it and seeing what you get. In cases where the function is expensive, this can be painful.</p>\n<p>I had high hopes for <code>Core.Compiler.return_type</code>, but currently it doesn't seem to help much. Maybe that will change?</p>",
        "id": 262322412,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1637589937
    },
    {
        "content": "<p><code>Core.Compiler.return_type</code> itself is internal anyway, no?</p>",
        "id": 262323502,
        "sender_full_name": "Sukera",
        "timestamp": 1637590389
    },
    {
        "content": "<p>if we get to dispatch on something like that, we will probably get syntax for it</p>",
        "id": 262323528,
        "sender_full_name": "Sukera",
        "timestamp": 1637590405
    },
    {
        "content": "<p>at its core, julia is still a dynamic language, you have to keep that in mind - just because we _can_ access some things from the compiler, doesn't mean we necessarily should</p>",
        "id": 262323585,
        "sender_full_name": "Sukera",
        "timestamp": 1637590441
    },
    {
        "content": "<p>(though I do think this desire will only grow stronger, to support static binaries better)</p>",
        "id": 262323646,
        "sender_full_name": "Sukera",
        "timestamp": 1637590456
    },
    {
        "content": "<p>I'd argue the opposite of that - It's referred to as a dynamic language, but just because you <em>can</em> ignore the types doesn't mean you should <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> </p>\n<p>I like Keno's description of \"locally static neighborhoods\" as the key to Julia's performance. So to make things better and faster, we should make those neighborhoods bigger, when we can. </p>\n<p>As for functions, the best workaround I've found for this is making structs callable, then using a type hierarchy for dispatch. Then you can dispatch on abstract types to encode things you know statically.</p>",
        "id": 262326411,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1637591687
    },
    {
        "content": "<blockquote>\n<p>I had high hopes for <code>Core.Compiler.return_type</code>, but currently it doesn't seem to help much. Maybe that will change?</p>\n</blockquote>\n<p>What do you mean by that? <code>return_type</code> does exactly what it's supposed to. Dispatching on it OTOH is usually a bad idea though, since because of the way Julia is designed, type inference is never guaranteed to be exact, so <code>Any</code> is always a valid answer for <code>return_type</code>.</p>",
        "id": 262340431,
        "sender_full_name": "Simeon Schaub",
        "timestamp": 1637597546
    },
    {
        "content": "<p>Just that it seems to return <code>Any</code> for cases that seem reasonable to infer. Maybe there's a way to help it, say adding methods to cases I know? Would that propagate correctly?</p>",
        "id": 262341545,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1637597976
    },
    {
        "content": "<p>depends on the specific case</p>",
        "id": 262342333,
        "sender_full_name": "Sukera",
        "timestamp": 1637598276
    },
    {
        "content": "<p>no idea if this is useful to you but you can always do this sort of pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span> <span class=\"o\">&lt;:</span> <span class=\"kt\">Tuple</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span>\n    <span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">)</span>  <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">}</span>           <span class=\"o\">=</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">toTuple</span><span class=\"p\">(</span><span class=\"kt\">Ts</span><span class=\"p\">),</span> <span class=\"kt\">Any</span><span class=\"p\">}(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Pair</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">toTuple</span><span class=\"p\">(</span><span class=\"kt\">Ts</span><span class=\"p\">),</span>   <span class=\"kt\">R</span><span class=\"p\">}(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">toTuple</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Type</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">})</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"n\">toTuple</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"o\">::</span><span class=\"kt\">Tuple</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Ts</span><span class=\"o\">...</span><span class=\"p\">}</span>\n\n<span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">})(</span>  <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"n\">invoke</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">R</span>\n<span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">Any</span><span class=\"p\">})(</span><span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">}</span>    <span class=\"o\">=</span> <span class=\"n\">invoke</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"k\">function</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"o\">::</span><span class=\"kt\">IO</span><span class=\"p\">,</span> <span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">})</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span> <span class=\"o\">&lt;:</span> <span class=\"kt\">Tuple</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span>\n    <span class=\"n\">Ts</span> <span class=\"o\">=</span> <span class=\"n\">collect</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"p\">,</span> <span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">),</span> <span class=\"s\">\"(::</span><span class=\"si\">$</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s\">\", ::</span><span class=\"si\">$</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"s\">\"</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">))</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"s\">\")::</span><span class=\"si\">$R</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">macro</span> <span class=\"n\">method</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"o\">::</span><span class=\"kt\">Expr</span><span class=\"p\">)</span>\n    <span class=\"nd\">@assert</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">∈</span> <span class=\"p\">(</span><span class=\"ss\">:call</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"ss\">:call</span>\n        <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"kt\">Any</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">R</span>  <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n        <span class=\"n\">ex</span> <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">Ts</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"k\">end</span><span class=\"p\">])</span> <span class=\"k\">do</span> <span class=\"n\">arg</span><span class=\"o\">::</span><span class=\"kt\">Expr</span>\n        <span class=\"nd\">@assert</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"o\">:</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"p\">)</span>\n        <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">)]</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"kt\">Tuple</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">)</span><span class=\"o\">...</span><span class=\"p\">),)</span> <span class=\"o\">=&gt;</span> <span class=\"o\">$</span><span class=\"n\">R</span><span class=\"p\">)))</span>\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 262358928,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637605723
    },
    {
        "content": "<p>and then</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">^</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span>\n<span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nd\">@method</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"o\">::</span><span class=\"kt\">Complex</span><span class=\"p\">)</span> <span class=\"o\">::</span> <span class=\"kt\">Complex</span>\n\n<span class=\"c\">#+RESULTS:</span>\n <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"o\">::</span><span class=\"kt\">Complex</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Complex</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">typeof</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span>\n\n<span class=\"c\">#+RESULTS:</span>\n <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">typeof</span><span class=\"p\">(</span><span class=\"kt\">f</span><span class=\"p\">),</span><span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span><span class=\"kt\">Complex</span><span class=\"p\">},</span><span class=\"kt\">Complex</span><span class=\"p\">}</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"nb\">im</span><span class=\"p\">)</span>\n\n<span class=\"c\">#+RESULTS:</span>\n <span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"nb\">im</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"nd\">@method</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"o\">::</span><span class=\"kt\">Complex</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Real</span>\n<span class=\"n\">m2</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"o\">+</span> <span class=\"nb\">im</span><span class=\"p\">)</span>\n\n<span class=\"c\">#+RESULTS:</span>\n <span class=\"kt\">TypeError</span><span class=\"o\">:</span> <span class=\"k\">in</span> <span class=\"n\">typeassert</span><span class=\"p\">,</span> <span class=\"n\">expected</span> <span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"n\">got</span> <span class=\"n\">a</span> <span class=\"n\">value</span> <span class=\"n\">of</span> <span class=\"n\">type</span> <span class=\"kt\">Complex</span><span class=\"p\">{</span><span class=\"kt\">Int64</span><span class=\"p\">}</span>\n</code></pre></div>",
        "id": 262358996,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637605760
    },
    {
        "content": "<p>Ok this is really interesting:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"nd\">@benchmark</span> <span class=\"o\">$</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"n\">setup</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"n\">rand</span><span class=\"p\">();</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">rand</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">rand</span><span class=\"p\">()</span><span class=\"nb\">im</span><span class=\"p\">)</span>\n<span class=\"n\">BenchmarkTools</span><span class=\"o\">.</span><span class=\"n\">Trial</span><span class=\"o\">:</span> <span class=\"mi\">10000</span> <span class=\"n\">samples</span> <span class=\"n\">with</span> <span class=\"mi\">1000</span> <span class=\"n\">evaluations</span><span class=\"o\">.</span>\n <span class=\"n\">Range</span> <span class=\"p\">(</span><span class=\"n\">min</span> <span class=\"o\">…</span> <span class=\"n\">max</span><span class=\"p\">)</span><span class=\"o\">:</span>  <span class=\"mf\">1.162</span> <span class=\"n\">ns</span> <span class=\"o\">…</span> <span class=\"mf\">4.749</span> <span class=\"n\">ns</span>  <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">min</span> <span class=\"o\">…</span> <span class=\"n\">max</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span> <span class=\"o\">…</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n <span class=\"n\">Time</span>  <span class=\"p\">(</span><span class=\"n\">median</span><span class=\"p\">)</span><span class=\"o\">:</span>     <span class=\"mf\">1.172</span> <span class=\"n\">ns</span>             <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">median</span><span class=\"p\">)</span><span class=\"o\">:</span>    <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n <span class=\"n\">Time</span>  <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"o\">±</span> <span class=\"n\">σ</span><span class=\"p\">)</span><span class=\"o\">:</span>   <span class=\"mf\">1.179</span> <span class=\"n\">ns</span> <span class=\"o\">±</span> <span class=\"mf\">0.074</span> <span class=\"n\">ns</span>  <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"o\">±</span> <span class=\"n\">σ</span><span class=\"p\">)</span><span class=\"o\">:</span>  <span class=\"mf\">0.00</span><span class=\"o\">%</span> <span class=\"o\">±</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n\n               <span class=\"n\">█</span>\n  <span class=\"n\">▂▁▁▁▁▁▁▁▁▁▁▁▁█▁▆▁▁▁▁▁▁▁▁▁▁▁▅▁▃▁▁▁▁▁▁▁▁▁▁▁▃▁▂▁▁▁▁▁▁▁▁▁▁▁▃▂</span> <span class=\"n\">▂</span>\n  <span class=\"mf\">1.16</span> <span class=\"n\">ns</span>        <span class=\"n\">Histogram</span><span class=\"o\">:</span> <span class=\"n\">frequency</span> <span class=\"n\">by</span> <span class=\"n\">time</span>        <span class=\"mf\">1.2</span> <span class=\"n\">ns</span> <span class=\"o\">&lt;</span>\n\n <span class=\"n\">Memory</span> <span class=\"n\">estimate</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"n\">bytes</span><span class=\"p\">,</span> <span class=\"n\">allocs</span> <span class=\"n\">estimate</span><span class=\"o\">:</span> <span class=\"mf\">0.</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"nd\">@benchmark</span> <span class=\"o\">$</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"n\">setup</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"n\">rand</span><span class=\"p\">();</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">rand</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">rand</span><span class=\"p\">()</span><span class=\"nb\">im</span><span class=\"p\">)</span>\n<span class=\"n\">BenchmarkTools</span><span class=\"o\">.</span><span class=\"n\">Trial</span><span class=\"o\">:</span> <span class=\"mi\">10000</span> <span class=\"n\">samples</span> <span class=\"n\">with</span> <span class=\"mi\">1000</span> <span class=\"n\">evaluations</span><span class=\"o\">.</span>\n <span class=\"n\">Range</span> <span class=\"p\">(</span><span class=\"n\">min</span> <span class=\"o\">…</span> <span class=\"n\">max</span><span class=\"p\">)</span><span class=\"o\">:</span>  <span class=\"mf\">1.162</span> <span class=\"n\">ns</span> <span class=\"o\">…</span> <span class=\"mf\">4.819</span> <span class=\"n\">ns</span>  <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">min</span> <span class=\"o\">…</span> <span class=\"n\">max</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span> <span class=\"o\">…</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n <span class=\"n\">Time</span>  <span class=\"p\">(</span><span class=\"n\">median</span><span class=\"p\">)</span><span class=\"o\">:</span>     <span class=\"mf\">1.182</span> <span class=\"n\">ns</span>             <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">median</span><span class=\"p\">)</span><span class=\"o\">:</span>    <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n <span class=\"n\">Time</span>  <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"o\">±</span> <span class=\"n\">σ</span><span class=\"p\">)</span><span class=\"o\">:</span>   <span class=\"mf\">1.182</span> <span class=\"n\">ns</span> <span class=\"o\">±</span> <span class=\"mf\">0.067</span> <span class=\"n\">ns</span>  <span class=\"n\">┊</span> <span class=\"n\">GC</span> <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"o\">±</span> <span class=\"n\">σ</span><span class=\"p\">)</span><span class=\"o\">:</span>  <span class=\"mf\">0.00</span><span class=\"o\">%</span> <span class=\"o\">±</span> <span class=\"mf\">0.00</span><span class=\"o\">%</span>\n\n                <span class=\"n\">█</span>             <span class=\"n\">▆</span>             <span class=\"n\">▆</span>\n  <span class=\"n\">█▃▁▁▁▁▁▁▁▁▁▁▁▁█▅▁▁▁▁▁▁▁▁▁▁▁▁█▅▁▁▁▁▁▁▁▁▁▁▁▁█▁▆▁▁▁▁▁▁▁▁▁▁▁▂</span> <span class=\"n\">▃</span>\n  <span class=\"mf\">1.16</span> <span class=\"n\">ns</span>        <span class=\"n\">Histogram</span><span class=\"o\">:</span> <span class=\"n\">frequency</span> <span class=\"n\">by</span> <span class=\"n\">time</span>        <span class=\"mf\">1.2</span> <span class=\"n\">ns</span> <span class=\"o\">&lt;</span>\n\n <span class=\"n\">Memory</span> <span class=\"n\">estimate</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"n\">bytes</span><span class=\"p\">,</span> <span class=\"n\">allocs</span> <span class=\"n\">estimate</span><span class=\"o\">:</span> <span class=\"mf\">0.</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">Core</span><span class=\"o\">.</span><span class=\"n\">Compiler</span><span class=\"o\">.</span><span class=\"n\">return_type</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Complex</span><span class=\"p\">})</span>\n<span class=\"kt\">Complex</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">Core</span><span class=\"o\">.</span><span class=\"n\">Compiler</span><span class=\"o\">.</span><span class=\"n\">return_type</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Complex</span><span class=\"p\">})</span>\n<span class=\"kt\">Any</span>\n</code></pre></div>",
        "id": 262360302,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1637606421
    },
    {
        "content": "<p>it's not too surprising imo</p>",
        "id": 262361082,
        "sender_full_name": "Sukera",
        "timestamp": 1637606822
    },
    {
        "content": "<p>it's basically helping inference along by asserting the return type at the end of the call</p>",
        "id": 262361100,
        "sender_full_name": "Sukera",
        "timestamp": 1637606833
    },
    {
        "content": "<p>Yeah. Inference basically refuses to work on abstract types</p>",
        "id": 262361774,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637607159
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">Core</span><span class=\"o\">.</span><span class=\"n\">Compiler</span><span class=\"o\">.</span><span class=\"n\">return_type</span><span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Real</span><span class=\"p\">})</span>\n\n<span class=\"c\">#+RESULTS:</span>\n<span class=\"o\">:</span> <span class=\"kt\">Any</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">Core</span><span class=\"o\">.</span><span class=\"n\">Compiler</span><span class=\"o\">.</span><span class=\"n\">return_type</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Real</span><span class=\"p\">})</span>\n\n<span class=\"c\">#+RESULTS:</span>\n<span class=\"o\">:</span> <span class=\"kt\">Real</span>\n</code></pre></div>",
        "id": 262361901,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637607227
    },
    {
        "content": "<p>There's no magic happening here</p>",
        "id": 262361917,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637607237
    },
    {
        "content": "<p>In fact, you can even just lie to the compiler this way:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">Core</span><span class=\"o\">.</span><span class=\"n\">Compiler</span><span class=\"o\">.</span><span class=\"n\">return_type</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">String</span><span class=\"p\">,</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Real</span><span class=\"p\">,</span> <span class=\"kt\">Real</span><span class=\"p\">})</span>\n\n<span class=\"c\">#+RESULTS:</span>\n<span class=\"o\">:</span> <span class=\"kt\">String</span>\n</code></pre></div>",
        "id": 262362031,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637607282
    },
    {
        "content": "<p>yup</p>",
        "id": 262362134,
        "sender_full_name": "Sukera",
        "timestamp": 1637607336
    },
    {
        "content": "<p>inference can't really know what <code>Real + Real</code> would be - they can't be instantiated after all</p>",
        "id": 262362173,
        "sender_full_name": "Sukera",
        "timestamp": 1637607362
    },
    {
        "content": "<p>imo that's a good thing, because I think that makes the trail you have to go search for until you find the instability much shorter</p>",
        "id": 262362269,
        "sender_full_name": "Sukera",
        "timestamp": 1637607389
    },
    {
        "content": "<p>This is why I think that type classes could be a potentially useful thing in julia even though we already have multiple dispatch. Besides being one way of expressing traits, they also allow you to express abstract type inference because they're more structured</p>",
        "id": 262362428,
        "sender_full_name": "Mason Protter",
        "timestamp": 1637607483
    },
    {
        "content": "<p>I just want to properly express that a thing is iterable AND indexable in the type system</p>",
        "id": 262367571,
        "sender_full_name": "Sukera",
        "timestamp": 1637609874
    },
    {
        "content": "<p>but without necessarily having it be <code>&lt;: AbstractArray</code> (non-rectangular and all that)</p>",
        "id": 262367683,
        "sender_full_name": "Sukera",
        "timestamp": 1637609916
    },
    {
        "content": "<p>really, <code>AbstractArray</code> should just mean <code>Indexable</code>, <code>Iterable</code> and <code>Rectangular</code></p>",
        "id": 262367734,
        "sender_full_name": "Sukera",
        "timestamp": 1637609953
    },
    {
        "content": "<p>Yeah, I  mostly use <a href=\"https://github.com/search?q=Tricks.jl&amp;type=Repositories\">Tricks.jl</a> to test for iterability, but it would be much better to have it built in and fast</p>",
        "id": 262369995,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1637611174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269150\">Mason Protter</span> <a href=\"#narrow/stream/274208-helpdesk-.28published.29/topic/Constraining.20method.20signatures/near/262358928\">said</a>:</p>\n<blockquote>\n<p>no idea if this is useful to you but you can always do this sort of pattern:</p>\n<p><div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span> <span class=\"o\">&lt;:</span> <span class=\"kt\">Tuple</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span>\n    <span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">)</span>  <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">}</span>           <span class=\"o\">=</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">toTuple</span><span class=\"p\">(</span><span class=\"kt\">Ts</span><span class=\"p\">),</span> <span class=\"kt\">Any</span><span class=\"p\">}(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Pair</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">toTuple</span><span class=\"p\">(</span><span class=\"kt\">Ts</span><span class=\"p\">),</span>   <span class=\"kt\">R</span><span class=\"p\">}(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">toTuple</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Type</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">})</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"n\">toTuple</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"o\">::</span><span class=\"kt\">Tuple</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"kt\">Tuple</span><span class=\"p\">{</span><span class=\"kt\">Ts</span><span class=\"o\">...</span><span class=\"p\">}</span>\n\n<span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">})(</span>  <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"n\">invoke</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">R</span>\n<span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">,</span> <span class=\"kt\">Any</span><span class=\"p\">})(</span><span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">Ts</span><span class=\"p\">}</span>    <span class=\"o\">=</span> <span class=\"n\">invoke</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">Ts</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"k\">function</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"o\">::</span><span class=\"kt\">IO</span><span class=\"p\">,</span> <span class=\"n\">M</span><span class=\"o\">::</span><span class=\"kt\">MethodWrapper</span><span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">})</span> <span class=\"k\">where</span> <span class=\"p\">{</span><span class=\"kt\">F</span><span class=\"p\">,</span> <span class=\"kt\">T</span> <span class=\"o\">&lt;:</span> <span class=\"kt\">Tuple</span><span class=\"p\">,</span> <span class=\"kt\">R</span><span class=\"p\">}</span>\n    <span class=\"n\">Ts</span> <span class=\"o\">=</span> <span class=\"n\">collect</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"p\">,</span> <span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">),</span> <span class=\"s\">\"(::</span><span class=\"si\">$</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s\">\", ::</span><span class=\"si\">$</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"s\">\"</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">))</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"s\">\")::</span><span class=\"si\">$R</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">macro</span> <span class=\"n\">method</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"o\">::</span><span class=\"kt\">Expr</span><span class=\"p\">)</span>\n    <span class=\"nd\">@assert</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">∈</span> <span class=\"p\">(</span><span class=\"ss\">:call</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"ss\">:call</span>\n        <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"kt\">Any</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">R</span>  <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n        <span class=\"n\">ex</span> <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">Ts</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"k\">end</span><span class=\"p\">])</span> <span class=\"k\">do</span> <span class=\"n\">arg</span><span class=\"o\">::</span><span class=\"kt\">Expr</span>\n        <span class=\"nd\">@assert</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"o\">:</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"p\">)</span>\n        <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">)]</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">MethodWrapper</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"kt\">Tuple</span><span class=\"p\">(</span><span class=\"n\">Ts</span><span class=\"p\">)</span><span class=\"o\">...</span><span class=\"p\">),)</span> <span class=\"o\">=&gt;</span> <span class=\"o\">$</span><span class=\"n\">R</span><span class=\"p\">)))</span>\n<span class=\"k\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"269150\">@Mason Protter</span> have you considered making this into a package? I think lots of people use <a href=\"https://github.com/search?q=FunctionWrappers.jl&amp;type=Repositories\">FunctionWrappers.jl</a> to solve this problem, but that adds a lot of overhead. <a href=\"https://github.com/search?q=Catlab.jl&amp;type=Repositories\">Catlab.jl</a> is one example:<br>\n<a href=\"https://github.com/AlgebraicJulia/Catlab.jl/issues/586#issuecomment-987502657\">https://github.com/AlgebraicJulia/Catlab.jl/issues/586#issuecomment-987502657</a><br>\n<span class=\"user-mention\" data-user-id=\"278517\">@Evan Patterson</span> <span class=\"user-mention\" data-user-id=\"270680\">@James Fairbanks</span></p>",
        "id": 264007088,
        "sender_full_name": "Chad Scherrer",
        "timestamp": 1638886566
    },
    {
        "content": "<p>Yeah I could stick it in a package if people would find it helpful.</p>",
        "id": 264027073,
        "sender_full_name": "Mason Protter",
        "timestamp": 1638894794
    }
]