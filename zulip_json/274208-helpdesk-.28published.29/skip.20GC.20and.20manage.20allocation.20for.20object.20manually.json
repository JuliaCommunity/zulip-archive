[
    {
        "content": "<p>Is there a way to manually take care of the allocation and deallocation of some object, making GC not be aware of it?</p>\n<p>The use case is the following: I have a program that depends on a lower-level C++ library, but that library generates some data, which on the Julia side is wrapped in a struct, that I have to clean very often, otherwise the memory blows up. However, if I call GC manually all the time, the program becomes way too slow. I would like to \"manually GC\" only that specific object. Since it is an object that wraps an underlying C++ data structure, I cannot just overwrite the data. </p>\n<p>(at a more lower level the issue is that the C++ code is leaking memory, but the bug is being tracked downstream but while it is not solved I would like to take care of the issue on my side).</p>",
        "id": 525424279,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750724355
    },
    {
        "content": "<p>I have a hard time figuring out how your data is represented and why <em>wrapping</em> C++ data causes memory problems on the Julia side. Is it possible to describe this with reasonably short code?</p>",
        "id": 525465724,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1750753513
    },
    {
        "content": "<p>Yeah, its somewhat hard to explain because we are trying to figure out a workaround for a bug we do not have full control of, which has its own issues but relates to other side-effects. </p>\n<p>But, in summary, I have a situation where I have to read a huge data file, sequentially (the positions of atoms in a simulation). There is a package, <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/Chemfiles\">Chemfiles.jl</a>, which wraps a C++ implementation of the reading of various formats for this file. </p>\n<p>The typical usage consists in a loop like</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">iframe</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">nframes</span>\n<span class=\"w\">     </span><span class=\"n\">positions</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">read_frame</span><span class=\"p\">(</span><span class=\"n\">trajectory_file</span><span class=\"p\">)</span>\n<span class=\"w\">     </span><span class=\"c\"># do cool stuff with the positions</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>at each iteration of the loop the <code>positions</code> object must be cleared, because they are huge and storing more than a few of those in memory crashes the computation. </p>\n<p>The garbage collector is not being effective in this process. Sometimes memory builds up and the computation crashes. Because of that, I have in my code something like after reading each frame:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Sys</span><span class=\"o\">.</span><span class=\"n\">free_memory</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">Sys</span><span class=\"o\">.</span><span class=\"n\">total_memory</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mf\">0.1</span>\n<span class=\"w\">                </span><span class=\"n\">GC</span><span class=\"o\">.</span><span class=\"n\">gc</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"k\">end</span>\n</code></pre></div>\n<p>where I call <code>GC.gc()</code> whenever the free memory is smaller than a threshold. This <strong>alleviates</strong> the issue, and crashes are less frequent. The issue (at this point) is that if I call <code>GC.gc()</code> too often (by using a large threshold), the code becomes much slower. Something from taking 2 minutes to taking 30 minutes, only because of calling the garbage collector at every step.</p>\n<p>And there is where I thought that a workaround could be to manually managing the memory of the <code>positions</code> object independently of the GC. That manually management would be easy except because the <code>positions</code> object is a wrapper of an underlying C++ object created by the <code>Chemfiles</code> library. </p>\n<p>So, there are mixed issues for which I'm trying to experiment workarounds:</p>\n<ol>\n<li>There is a library which exposes an object over which I do not have full control.</li>\n<li>The Julia GC does not seem to completely be aware of that object, such that memory can blow out. This might be a bug on the underlying C++ library. Something related <a href=\"https://github.com/chemfiles/Chemfiles.jl/issues/83#issuecomment-2731030554\">is being tracked</a>, but we don't know what's the issue yet. </li>\n<li>Calling GC on every step does alleviate the issue, such that the object seems to be tracked by GC, but that is comming with a huge performance cost (and we are not talking about tight loops here, but on delays of the order of tenths of minutes).</li>\n</ol>\n<p>Any insight is appreciated. In any case explaning the issue helps me figuring out what might be done.</p>",
        "id": 525497648,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750765002
    },
    {
        "content": "<p>What is this object? Is it basically just a mutable struct?</p>",
        "id": 525509843,
        "sender_full_name": "Mason Protter",
        "timestamp": 1750769084
    },
    {
        "content": "<p>One thing I've done before for handling mutable data separately from Julia's GC is this:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">module</span><span class=\"w\"> </span><span class=\"n\">PtrStructs</span>\n\n<span class=\"k\">struct</span> <span class=\"kt\">PtrStruct</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">PtrStruct</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">isbitstype</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"kt\">new</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">            </span><span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s\">\"PtrStruct only works with isbits types.\"</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"k\">end</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n<span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">PtrStruct</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">getfield</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">:ptr</span><span class=\"p\">)</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">getindex</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">PtrStruct</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">unsafe_load</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">setindex!</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">PtrStruct</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">unsafe_store!</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">convert</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">T</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"nd\">@generated</span><span class=\"w\"> </span><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">getproperty</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">PtrStruct</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"kt\">Symbol</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">foldl</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">fieldcount</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">=:</span><span class=\"p\">(</span><span class=\"n\">invalid_propertyname_error</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">)))</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">ex</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">        </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldname</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldoffset</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldtype</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"kt\">Expr</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"ss\">:if</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">===</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"kt\">QuoteNode</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))),</span>\n<span class=\"w\">            </span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">unsafe_load</span><span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"o\">$</span><span class=\"kt\">type</span><span class=\"p\">}(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"n\">offset</span><span class=\"p\">))),</span>\n<span class=\"w\">            </span><span class=\"n\">ex</span>\n<span class=\"w\">        </span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"nd\">@generated</span><span class=\"w\"> </span><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">setproperty!</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">PtrStruct</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"kt\">Symbol</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">foldl</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">fieldcount</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">=:</span><span class=\"p\">(</span><span class=\"n\">invalid_propertyname_error</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">)))</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">ex</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">        </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldname</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldoffset</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fieldtype</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"kt\">Expr</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"ss\">:if</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">===</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"kt\">QuoteNode</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))),</span>\n<span class=\"w\">            </span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">unsafe_store!</span><span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"o\">$</span><span class=\"kt\">type</span><span class=\"p\">}(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"n\">offset</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">convert</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"n\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">::$</span><span class=\"n\">type</span><span class=\"p\">)),</span>\n<span class=\"w\">            </span><span class=\"n\">ex</span>\n<span class=\"w\">        </span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"nd\">@noinline</span><span class=\"w\"> </span><span class=\"n\">invalid_propertyname_error</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Type</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"kt\">Symbol</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">throw</span><span class=\"p\">(</span><span class=\"kt\">ArgumentError</span><span class=\"p\">(</span><span class=\"s\">\"Invalid propertyname </span><span class=\"si\">$s</span><span class=\"s\"> for object of type </span><span class=\"si\">$T</span><span class=\"s\">\"</span><span class=\"p\">))</span>\n\n<span class=\"k\">end</span><span class=\"w\"> </span><span class=\"c\"># module PtrStructs</span>\n</code></pre></div>",
        "id": 525510114,
        "sender_full_name": "Mason Protter",
        "timestamp": 1750769167
    },
    {
        "content": "<p>and then you can basically bring your own pointer, make your own objects with <code>setproperty!</code> and then free the pointer later when you're done with it. i.e. old fashioned memory management with all it's upsides and downsides</p>",
        "id": 525510288,
        "sender_full_name": "Mason Protter",
        "timestamp": 1750769223
    },
    {
        "content": "<p>This is your problem: <a href=\"https://github.com/chemfiles/Chemfiles.jl/blob/master/src/utils.jl#L5-L16\">https://github.com/chemfiles/Chemfiles.jl/blob/master/src/utils.jl#L5-L16</a></p>\n<p>C++ memory is indeed wrapped by a mutable struct which automatically frees the memory from a finalizer when it is garbage collected. But Julia doesn't see that memory, so it doesn't put any pressure on the GC to collect garbage.</p>",
        "id": 525537034,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1750776746
    },
    {
        "content": "<p>If it is safe to call <code>lib.chfl_free</code> twice, you could possibly work around this by searching your objects for <code>CxxPointer</code>s and manually freeing them before letting your objects go out of scope.</p>",
        "id": 525538986,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1750777309
    },
    {
        "content": "<p>Actually I had never seen this function before</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">help</span><span class=\"o\">?&gt;</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">finalize</span>\n<span class=\"w\">  </span><span class=\"n\">finalize</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">Immediately</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">finalizers</span><span class=\"w\"> </span><span class=\"n\">registered</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>which might do what you need, provided you can track down the <code>CxxPointer</code>s.</p>",
        "id": 525541345,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1750778018
    },
    {
        "content": "<p>Uhm, that's interesting. Actually my function reads the data and copies it to a Julia data structure right away, and the objects get out of scope in a very localized way. I added the <code>finalize()</code> calls after returning from the function. Is that what you mean by that? (I'm not sure if this makes sense, and by testing it didn't really seem to work, at first sight):</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">nextframe!</span><span class=\"p\">(</span><span class=\"n\">trajectory</span><span class=\"o\">::</span><span class=\"kt\">ChemFile</span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"n\">st</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">stream</span><span class=\"p\">(</span><span class=\"n\">trajectory</span><span class=\"p\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">frame</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Chemfiles</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">st</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">positions</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Chemfiles</span><span class=\"o\">.</span><span class=\"n\">positions</span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">uc0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Chemfiles</span><span class=\"o\">.</span><span class=\"n\">UnitCell</span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">ucm</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Chemfiles</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">uc0</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">unitcell</span><span class=\"w\"> </span><span class=\"o\">.=</span><span class=\"w\"> </span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"kt\">SMatrix</span><span class=\"p\">{</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">}(</span><span class=\"n\">ucm</span><span class=\"p\">))</span>\n\n<span class=\"w\">    </span><span class=\"c\"># Save coordinates of solute and solvent in trajectory arrays (of course this could be avoided,</span>\n<span class=\"w\">    </span><span class=\"c\"># but the code in general is more clear aftwerwards by doing this)</span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">eachindex</span><span class=\"p\">(</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">x_solute</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">x_solute</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solute</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solute</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solute</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">        </span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">eachindex</span><span class=\"p\">(</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">x_solvent</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">x_solvent</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solvent</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solvent</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">            </span><span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">solvent</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span>\n<span class=\"w\">        </span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">    </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">finalize</span><span class=\"p\">(</span><span class=\"n\">uc0</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">finalize</span><span class=\"p\">(</span><span class=\"n\">ucm</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">finalize</span><span class=\"p\">(</span><span class=\"n\">positions</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">finalize</span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">)</span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">trajectory</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>(In this code <code>ChemFile</code> is a standard Julia type manage myself, with all Julia structures except the trajectory \"stream\" (<code>stream::Stream{&lt;:Chemfiles.Trajectory}</code>).</p>",
        "id": 525556963,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750783086
    },
    {
        "content": "<p>In parallel, to solve the underlying issue in the <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/Chemfiles\">Chemfiles.jl</a> package, what would be the proper way to wrap a C++ object such that Julia does see its size?  I guess this is a common scenario.</p>",
        "id": 525559850,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750784101
    },
    {
        "content": "<p>I don't think <code>finalize</code> is a very useful function, certainly not in the example code immediately above. <code>finalize</code> just runs the registered finalizers. I think this is useless if these objects (<code>uc0</code>, <code>ucm</code>, etc.) are unreachable at the end of the function, because the finalizers get run anyway when the objects get garbage collected.</p>",
        "id": 525598515,
        "sender_full_name": "Neven Sajko",
        "timestamp": 1750800702
    },
    {
        "content": "<p>At least that agrees with the fact that what I did didn´t work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>Is there a way to garbage collect those specific objects before leaving the function?</p>",
        "id": 525600276,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750801441
    },
    {
        "content": "<p>(and would that, if existed, be faster than run a full GC?)</p>",
        "id": 525601008,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750801806
    },
    {
        "content": "<p>Author of chemfiles here =) </p>\n<p>One possible reason why <code>finalize</code> does not help is that we are keeping a reference to the frame inside the <code>positions</code> array (otherwise julia could access freed memory). Maybe first setting <code>positions</code> to <code>nothing</code> would help. Does anyone knows if <code>finalize</code> runs the finalizers regardless of the reference count of the object? </p>\n<p>I'm also not 100% sure the issue is that the GC does not see memory pressure, because I tried to replace the C++ allocators with <code>jl_malloc</code> and <code>jl_free</code>, which AFAIU should be enough for the GC to know more about the actual memory pressure, but also did not help in my testing.</p>",
        "id": 525608351,
        "sender_full_name": "Luthaf",
        "timestamp": 1750806210
    },
    {
        "content": "<blockquote>\n<p>I think this is useless if these objects (<code>uc0</code>, <code>ucm</code>, etc.) are unreachable at the end of the function, because the finalizers get run anyway when the objects get garbage collected.</p>\n</blockquote>\n<p>I'm not sure I follow you here: from my understanding Julia GC (contrary to e.g. Python's GC which only uses reference counting) does not immediately collect non-reachable objects, and there can be a large delay between the object being unreachable and the object being collected. But <code>finalize</code> not helping is also strange, so I might be missing something here …</p>",
        "id": 525608616,
        "sender_full_name": "Luthaf",
        "timestamp": 1750806406
    },
    {
        "content": "<p>FWIW, I just tried setting all objects to <code>nothing</code> before calling <code>finalize</code> on each one in the code above, but didn't see any improvement.</p>\n<p>(also, I remember being able to reproduce the issue in the Python interface of Chemfiles, but that might have nothing to do with the issue here)</p>",
        "id": 525616561,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750811600
    },
    {
        "content": "<p>Also I do not think that GC is completely unaware of the memory of each <code>positions</code> object. It does free memory, and calling it more frequently alleviates the issue. But for some reason something ends up leaking, but it is not the full memory of the object, for sure.</p>",
        "id": 525616708,
        "sender_full_name": "Leandro Martínez",
        "timestamp": 1750811735
    },
    {
        "content": "<p>Overwriting with <code>nothing</code> will not help, Julia is smarter than that.</p>",
        "id": 525709940,
        "sender_full_name": "Neven Sajko",
        "timestamp": 1750857132
    },
    {
        "content": "<p>Taking a step back here: as far as I understand, it's still not known for certain what is leaking? Perhaps inspecting heap snapshots might be a good first step?</p>",
        "id": 525710755,
        "sender_full_name": "Neven Sajko",
        "timestamp": 1750857360
    },
    {
        "content": "<p>Even though the heap snapshots only show what's tracked by GC, maybe it could be useful.</p>",
        "id": 525720725,
        "sender_full_name": "Neven Sajko",
        "timestamp": 1750860198
    }
]