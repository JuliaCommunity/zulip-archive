[
    {
        "content": "<p>I am working on a problem where I would like parts of a model to emit small immutable results, but they aggregate into something with a lot more fields. The states depend on a collection of heterogeneous actor types. My two questions:</p>\n<ol>\n<li>Say I've got a 'dense' set of state deltas but each of my underlying model components generally uses a subset (&lt; half) of the overall states. Is this an efficient way to do this immutably? I think the alternative is to define the components as mutable and then have each agent sequentially modify them. I'm looking for efficiency due to creating millions of these components in a simulation.</li>\n<li>The collection I'm operation on has heterogeneous types. I explored SumTypes and enum alternatives, but since I dispatch on the type (<code>Actor</code>s below) those approaches didn't seem to work for me. Is there a recommended pattern instead? E.g. a Dict <code>Dict(Actor1 =&gt; [...Actor1s...], Actor2 =&gt; [...Actor2s...],...)</code>?</li>\n</ol>\n<p>basic example:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">import</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">+</span>\n\n<span class=\"c\"># state components really represent the *change* in system state</span>\n<span class=\"k\">abstract</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"kt\">AbstractComponent</span><span class=\"w\"> </span><span class=\"k\">end</span>\n\n<span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"nd\">@kwdef</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"kt\">ComponentA</span><span class=\"w\"> </span><span class=\"o\">&lt;:</span><span class=\"w\"> </span><span class=\"kt\">AbstractComponent</span>\n<span class=\"w\">   </span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">c</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">d</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">e</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">g</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"nd\">@kwdef</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"kt\">ComponentB</span><span class=\"w\"> </span><span class=\"o\">&lt;:</span><span class=\"w\"> </span><span class=\"kt\">AbstractComponent</span>\n<span class=\"w\">   </span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">i</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">j</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">k</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">l</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">m</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">n</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"nd\">@kwdef</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"kt\">ComponentC</span><span class=\"w\"> </span><span class=\"o\">&lt;:</span><span class=\"w\"> </span><span class=\"kt\">AbstractComponent</span>\n<span class=\"w\">   </span><span class=\"n\">o</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">q</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">r</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">u</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">v</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"w\">   </span><span class=\"n\">w</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">struct</span> <span class=\"kt\">ModelState</span>\n<span class=\"w\">    </span><span class=\"n\">compA</span><span class=\"o\">::</span><span class=\"kt\">ComponentA</span>\n<span class=\"w\">    </span><span class=\"n\">compB</span><span class=\"o\">::</span><span class=\"kt\">ComponentB</span>\n<span class=\"w\">    </span><span class=\"n\">compC</span><span class=\"o\">::</span><span class=\"kt\">ComponentC</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">Base</span><span class=\"o\">.:+</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"kt\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"kt\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"o\">&lt;:</span><span class=\"kt\">AbstractComponent</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">([(</span><span class=\"n\">getfield</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">getfield</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">fieldnames</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)]</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">Base</span><span class=\"o\">.:+</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"kt\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"kt\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kt\">T</span><span class=\"o\">&lt;:</span><span class=\"kt\">ModelState</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">([(</span><span class=\"n\">getfield</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">getfield</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">fieldnames</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)]</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">abstract</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"kt\">AbstractActor</span><span class=\"w\"> </span><span class=\"k\">end</span>\n<span class=\"k\">struct</span> <span class=\"kt\">Actor1</span><span class=\"w\"> </span><span class=\"k\">end</span>\n<span class=\"k\">struct</span> <span class=\"kt\">Actor2</span><span class=\"w\"> </span><span class=\"k\">end</span>\n<span class=\"k\">struct</span> <span class=\"kt\">Actor3</span><span class=\"w\"> </span><span class=\"k\">end</span>\n\n<span class=\"n\">evolve</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Actor1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ModelState</span><span class=\"p\">(</span><span class=\"n\">ComponentA</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"n\">ComponentB</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"n\">ComponentC</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()))</span>\n<span class=\"n\">evolve</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Actor2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ModelState</span><span class=\"p\">(</span><span class=\"n\">ComponentA</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"n\">ComponentB</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"n\">ComponentC</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()))</span>\n<span class=\"n\">evolve</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Actor3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ModelState</span><span class=\"p\">(</span><span class=\"n\">ComponentA</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"n\">ComponentB</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"n\">ComponentC</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">(),</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rand</span><span class=\"p\">()))</span>\n\n<span class=\"n\">heterogeneous_actors</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Actor1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor2</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">()]</span>\n\n<span class=\"n\">state_deltas</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">evolve</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">heterogeneous_actors</span><span class=\"p\">)</span>\n\n<span class=\"c\"># the evolution of the system state through time</span>\n<span class=\"n\">states</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">state_deltas</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>I have the components and agents in separate because in my real code I dispatch behavior (e.g. components enforce some relationships between fields, agents actually have more complex behavior, custom show methods for the different types). In the real problem, I have 10'000s of actors and 1000's of time steps.</p>",
        "id": 558076236,
        "sender_full_name": "Alec",
        "timestamp": 1763503797
    },
    {
        "content": "<p>Is <a href=\"https://discourse.julialang.org/t/ann-ark-jl-archetype-based-entity-component-system-ecs-for-games-and-simulations/133851\">https://discourse.julialang.org/t/ann-ark-jl-archetype-based-entity-component-system-ecs-for-games-and-simulations/133851</a> of any relevance to this problem?</p>",
        "id": 558125997,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1763534981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"273176\">@Gunnar Farnebäck</span> Thanks, this is very interesting. I've spent some time looking at this and reading up on ECS systems. From what I can tell, <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/Ark\">Ark.jl</a>/ECS systems benefit modeling when you are trying to control/update components depending on their group membership or properties (accomplished via <code>Query</code>). E.g. only update entities with a position property. I think my use case/objective is a bit different.</p>\n<p>My actual use case has <em>every</em> entity get updated each tilmestep. The related output (I called it component) just is kind of sparse. My actual use case is related to JuliaActuary -relating the MWE example above to what I'm actually trying to do is model a block of business for an insurance company:</p>\n<ul>\n<li>Components are financial statements where I am trying to enforce some properties (akin to double entry accounting)</li>\n<li>Actors are assets/liabilities</li>\n<li>Every tilmestep something happens to both assets and liabilities (e.g. a bond pays a coupon, a policy liability pays a premium or has a claim) so in all of the components of the financial statement what each actor (asset/liability) touches is fairly small subset but summing up everything gets you a complete, populated set of financial statements.</li>\n</ul>",
        "id": 558248690,
        "sender_full_name": "Alec",
        "timestamp": 1763569249
    },
    {
        "content": "<p>I have no more insights to share since I've never worked with these kinds of problems. It just seemed like something that could be in the same domain.</p>",
        "id": 558250737,
        "sender_full_name": "Gunnar Farnebäck",
        "timestamp": 1763569694
    },
    {
        "content": "<p>Given that you only update a couple of fields at a time, I’d suggest keep them immutable and use Accessors to efficiently generate new objects. </p>\n<p>Regarding the heterogenous actors why didn’t sum types work (Or any of the alternatives)? It’s kind of exactly what you need in this case: A closed union such that the compiler can union split efficiently. (By the way it could also help with the abstract components probably)</p>\n<p>Are the updated fields in the components always the same for each actor?</p>",
        "id": 558259079,
        "sender_full_name": "cschen",
        "timestamp": 1763571766
    },
    {
        "content": "<p>For sum types, I wanted users to be able to declare their own subtypes and inherit methods if possible, otherwise define their own. AFAICT sum types doesn’t allow for this.</p>\n<p>Yes, the components are always the same for each actor.</p>",
        "id": 558952404,
        "sender_full_name": "Alec",
        "timestamp": 1763960127
    },
    {
        "content": "<p>The way I handle stuff like this in <a href=\"https://juliaregistries.github.io/General/packages/redirect_to_repo/GraphDynamics\">GraphDynamics.jl</a> is to partition the list of actors by their type. E.g. suppose you had</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"n\">heterogeneous_actors</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Actor1</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor2</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor1</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor2</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Actor1</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)]</span>\n</code></pre></div>\n<p>then as a setup-step before the actual silulation, I would do</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">partition_actors</span><span class=\"p\">(</span><span class=\"n\">actors</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"c\"># Contain all the type instability into this step!</span>\n<span class=\"w\">    </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">Tuple</span><span class=\"p\">(</span><span class=\"n\">unique</span><span class=\"p\">((</span><span class=\"n\">typeof</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">actor</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">actors</span><span class=\"p\">)))</span>\n<span class=\"w\">    </span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">        </span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">actor</span><span class=\"w\"> </span><span class=\"k\">isa</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">actors</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">actors_partitioned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">partition_actors</span><span class=\"p\">(</span><span class=\"n\">heterogeneous_actors</span><span class=\"p\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"c\">#+Results</span>\n<span class=\"p\">([</span><span class=\"n\">Actor1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor1</span><span class=\"p\">()],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Actor3</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor3</span><span class=\"p\">()],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Actor2</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Actor2</span><span class=\"p\">()])</span>\n</code></pre></div>\n<p>Now you have an object you can work with in a type-stable, efficient manner later on.</p>",
        "id": 559012230,
        "sender_full_name": "Mason Protter",
        "timestamp": 1763982406
    },
    {
        "content": "<p>This approach might be overkill for your needs though. I did it that way because the equivalent of the states and components were also unique per-actor, and I also needed to support arbitrary, but type stable communication between each different actor</p>",
        "id": 559012609,
        "sender_full_name": "Mason Protter",
        "timestamp": 1763982505
    },
    {
        "content": "<hr>\n<p>If you want a Sum-Types-like approach, but where users can still make their own types and you don't want to have to manually enumerate all possible types up-front, you could do it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"kt\">ActorWrapper</span><span class=\"p\">{</span><span class=\"kt\">PossibleTypes</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">actor</span><span class=\"o\">::</span><span class=\"kt\">PossibleTypes</span>\n<span class=\"k\">end</span>\n<span class=\"n\">unwrap</span><span class=\"p\">(</span><span class=\"n\">aw</span><span class=\"o\">::</span><span class=\"kt\">ActorWrapper</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">aw</span><span class=\"o\">.</span><span class=\"n\">actor</span>\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">wrap_actors</span><span class=\"p\">(</span><span class=\"n\">actors</span><span class=\"p\">)</span>\n<span class=\"w\">     </span><span class=\"c\"># Contain all the type instability into this step!</span>\n<span class=\"w\">    </span><span class=\"n\">possible_types</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">Union</span><span class=\"p\">{</span><span class=\"kt\">unique</span><span class=\"p\">((</span><span class=\"kt\">typeof</span><span class=\"p\">(</span><span class=\"kt\">actor</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">for</span><span class=\"w\"> </span><span class=\"kt\">actor</span><span class=\"w\"> </span><span class=\"kt\">in</span><span class=\"w\"> </span><span class=\"kt\">actors</span><span class=\"p\">))</span><span class=\"o\">...</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"kt\">ActorWrapper</span><span class=\"p\">{</span><span class=\"kt\">possible_types</span><span class=\"p\">}</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">actors</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">actors_wrapped</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wrap_actors</span><span class=\"p\">(</span><span class=\"n\">heterogeneous_actors</span><span class=\"p\">)</span>\n\n<span class=\"n\">state_deltas</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">evolve</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">unwrap</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">actors_wrapped</span><span class=\"p\">))</span>\n<span class=\"n\">states</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">state_deltas</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>I suspect that's good enough for your use-case here since all the <code>ModelStates</code> are of the same type.</p>",
        "id": 559014468,
        "sender_full_name": "Mason Protter",
        "timestamp": 1763983020
    },
    {
        "content": "<p>That said, I tried some benchmarks with various sizes, and with adding more and more different actor types, and I found that while both of my suggestions sped up the <code>evolve.(...)</code> step, those speedups were irrelevant because the <code>cumsum</code> operation took orders of magnitude more time.</p>",
        "id": 559019327,
        "sender_full_name": "Mason Protter",
        "timestamp": 1763984385
    },
    {
        "content": "<p>Thanks, as always, <span class=\"user-mention\" data-user-id=\"269150\">@Mason Protter</span> .  I will try some of these in the next round of development.</p>",
        "id": 561065146,
        "sender_full_name": "Alec",
        "timestamp": 1764565613
    }
]