[
    {
        "content": "<p>I've heard that <a href=\"https://juliahub.com/ui/Packages/General/Enzyme\">Enzyme.jl</a> supports array mutation and I'm trying to refine my understanding of what that means. The Enzyme docs get fairly dense pretty quickly.</p>\n<p>And to hit the XY problem on the head, I'm trying to do this in the context of some simulations which add/remove elements from arrays and trying to see if I can get the benefit of AD in solving for parameters. Here's a contrived example, which Enzyme fails on with the error below:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">cashflows</span><span class=\"p\">,</span><span class=\"n\">r</span><span class=\"p\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">assets</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">Float64</span><span class=\"p\">[]</span>\n\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">cf</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cfs</span>\n<span class=\"w\">        </span><span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">assets</span><span class=\"p\">,</span><span class=\"n\">cashflows</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">assets</span><span class=\"w\"> </span><span class=\"o\">.*=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">+</span><span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">    </span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">assets</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n<span class=\"n\">gradient</span><span class=\"p\">(</span><span class=\"n\">Forward</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">f</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>errors with:</p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"kt\">MethodError</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">method</span><span class=\"w\"> </span><span class=\"n\">matching</span><span class=\"w\"> </span><span class=\"n\">similar</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"kt\">Float64</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>So I think my questions are:</p>\n<ol>\n<li>What type of mutations does enzyme support and not support? </li>\n<li>This <a href=\"https://enzyme.mit.edu/index.fcgi/julia/stable/#Activity-of-temporary-storage\">example</a> with the <code>tmp</code> seems overly contrived that I'm not sure where I'd see that type of thing in practice? </li>\n<li>XY problem question: Any experience doing simulations of asset and liabilites and getting AD to work on the end-to-end simulation? (I don't really expect answers here)</li>\n</ol>",
        "id": 419378644,
        "sender_full_name": "Alec",
        "timestamp": 1706845334
    },
    {
        "content": "<blockquote>\n<p>This example with the tmp seems overly contrived that I'm not sure where I'd see that type of thing in practice?</p>\n</blockquote>\n<p>All package code does that because it's the most performant way to do things. Not sure it's contrived given it's one of the most common coding patterns to pass in a cache struct <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. Normally you'd put it to the front and <code>!</code> it, then also normally you'd use the whole thing, but this is showing some of the edge cases and how to handle them associated with mutation so it's doing a bit more complicated of a case than the standard.</p>\n<blockquote>\n<p>XY problem question: Any experience doing simulations of asset and liabilites and getting AD to work on the end-to-end simulation? (I don't really expect answers here)</p>\n</blockquote>\n<p>In terms of SDEs, yes quite a bit.</p>",
        "id": 419456853,
        "sender_full_name": "Christopher Rackauckas",
        "timestamp": 1706880259
    },
    {
        "content": "<blockquote>\n<p>What type of mutations does enzyme support and not support?</p>\n</blockquote>\n<p>I'm not sure there are any that aren't generally supported? Mutable structs, arrays, etc. are all fine. <code>Memory</code> might not be supported yet, but that's because it's not even released yet <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>, but that should get support when it's released. Mutation is actually the easy thing for Enzyme. Allocation (i.e. handling GC) is harder.</p>",
        "id": 419456927,
        "sender_full_name": "Christopher Rackauckas",
        "timestamp": 1706880291
    },
    {
        "content": "<p>In fact with Enzyme, generally if you're having issues the best thing to do is to remove allocations and rely on mutation more, given that the thing it trips on the most is autodiff of the GC</p>",
        "id": 419457190,
        "sender_full_name": "Christopher Rackauckas",
        "timestamp": 1706880382
    },
    {
        "content": "<p>Your problem there is just that you wrote down a description that doesn't make mathematical sense. The gradient isn't defined on a scalar function. The gradient is a vector-function operation. Yes it's homeomorphic to the operation defined on a vector of one thing, but that has a very different computational representation. So you should be asking for the derivative if you want the derivative, not asking for the gradient if you want the derivative.</p>",
        "id": 419457518,
        "sender_full_name": "Christopher Rackauckas",
        "timestamp": 1706880494
    },
    {
        "content": "<p>I think it makes more sense... a way to read this:</p>\n<blockquote>\n<p>Activity of temporary storage. If you pass in any temporary storage which may be involved in an active computation to a function you want to differentiate, you must also pass in a duplicated temporary storage for use in computing the derivatives. </p>\n</blockquote>\n<p>Is that you need to avoid allocating memory inside the function and the <code>tmp</code> array is really just the usual pattern for pre-allocating some storage for use in the function. </p>\n<p>You are right that the lack of <code>!</code> and not putting the temporary container as the first argument threw me off here.</p>",
        "id": 419572662,
        "sender_full_name": "Alec",
        "timestamp": 1706932618
    },
    {
        "content": "<p>I was able to get my example to work the way I inteded with: </p>\n<div class=\"codehilite\" data-code-language=\"Julia\"><pre><span></span><code><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">cfs</span><span class=\"p\">,</span><span class=\"n\">assets</span><span class=\"p\">,</span><span class=\"n\">r</span><span class=\"p\">)</span>\n\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">eachindex</span><span class=\"p\">(</span><span class=\"n\">cfs</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">assets</span><span class=\"p\">,</span><span class=\"n\">cfs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n<span class=\"w\">        </span><span class=\"n\">assets</span><span class=\"w\"> </span><span class=\"o\">.*=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">+</span><span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">    </span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">assets</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">Enzyme</span><span class=\"o\">.</span><span class=\"n\">autodiff</span><span class=\"p\">(</span><span class=\"n\">Reverse</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Const</span><span class=\"p\">(</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"mf\">1.</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)),</span><span class=\"n\">Duplicated</span><span class=\"p\">(</span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">}(</span><span class=\"nb\">undef</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">}(</span><span class=\"nb\">undef</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"n\">Active</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">))</span>\n</code></pre></div>",
        "id": 419572742,
        "sender_full_name": "Alec",
        "timestamp": 1706932703
    }
]